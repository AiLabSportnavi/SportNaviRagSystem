{
  "nodes": [
    {
      "parameters": {
        "options": {
          "reset": false
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -5920,
        2224
      ],
      "id": "6a98f03c-a9b8-401f-b1a0-865716068273",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "b7292cf9-abfe-47c7-9136-1c1b864fd995",
              "name": "CONTENT",
              "value": "={{ $('SET PARMETER FOR NAME CONSISTENCY').first().json.CONTENT }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2112,
        1968
      ],
      "id": "9b1962d2-60d8-4938-8e97-929513847a9f",
      "name": "GET COTENT TO FEED TO THE VECTORE TO STORE "
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "b020e9ed-2eda-4c37-93a4-b0d413403f64",
                    "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim() }}",
                    "rightValue": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "DOC"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim() }}",
                    "rightValue": "=application/pdf",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "69de945c-9e44-4b46-86f6-1b8ce46a0e9f"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PDF"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "cdfbb4d9-f6d9-4ec8-b78b-c4740cbdcc79",
                    "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim() }}",
                    "rightValue": "application/vnd.google-apps.document",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "GOOGLE DOCS"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "2a333d4d-16ec-4c36-b865-33985647ab6c",
                    "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim() }}",
                    "rightValue": "=text/html",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "TEXT/HTML"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "b58226f9-d089-40d6-bb9a-b00619abd958",
                    "leftValue": "={{ $('WEB SCRAPING WEBHOOK').isExecuted }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "HTML"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "5cfc7d67-8b7b-4cbb-a7b2-4aa2ecf90a69",
                    "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim() }}",
                    "rightValue": "=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "EXCEL/XLSX"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "13f389e8-9e27-4268-ae20-46035304de88",
                    "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim() }}",
                    "rightValue": "text/csv",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "EXCEL"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "eaf2a408-8004-41d4-b502-b9560d214a8b",
                    "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim() }}",
                    "rightValue": "application/vnd.google-apps.spreadsheet",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "CSV"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "d850a557-357b-46c6-9bed-ebf239f05d8d",
                    "leftValue": "={{ [\n  \"application/x-t602\",\n  \"application/x-abiword\",\n  \"image/cgm\",\n  \"application/x-appleworks\",\n  \"application/msword\",\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n  \"application/vnd.ms-word.document.macroEnabled.12\",\n  \"application/msword\",\n  \"application/vnd.ms-word.template.macroEnabled.12\",\n  \"application/x-hwp\",\n  \"application/vnd.apple.keynote\",\n  \"application/vnd.lotus-wordpro\",\n  \"application/x-mw\",\n  \"application/x-mcw\",\n  \"application/vnd.apple.pages\",\n  \"application/vnd.powerbuilder6\",\n  \"application/vnd.ms-powerpoint\",\n  \"application/vnd.ms-powerpoint.presentation.macroEnabled.12\",\n  \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n  \"application/vnd.oasis.opendocument.presentation\",\n  \"application/vnd.ms-powerpoint.template.macroEnabled.12\",\n  \"application/vnd.openxmlformats-officedocument.presentationml.template\",\n  \"application/rtf\",\n  \"application/vnd.stardivision.draw\",\n  \"application/vnd.stardivision.impress\",\n  \"application/sdp\",\n  \"application/vnd.stardivision.writer\",\n  \"application/vnd.stardivision.writer-global\",\n  \"application/vnd.sun.xml.impress.template\",\n  \"application/vnd.sun.xml.impress\",\n  \"application/vnd.sun.xml.writer\",\n  \"application/vnd.sun.xml.writer.template\",\n  \"application/vnd.sun.xml.writer.global\",\n  \"text/plain\",\n  \"application/x-uof\",\n  \"application/x-uop\",\n  \"application/x-uot\",\n  \"application/vnd.stardivision.writer\",\n  \"application/vnd.wordperfect\",\n  \"application/vnd.ms-works\",\n  \"application/xml\",\n  \"application/x-abiword\",\n  \"application/epub+zip\"\n].includes($('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE.trim()) }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Any Other Files Types"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -4576,
        2016
      ],
      "id": "4552df20-369a-4c2a-91e6-746dafbb2943",
      "name": "SWITCH ON FILE TYPE "
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": {
          "__rl": true,
          "value": "={{ $json.DOC_ID }}",
          "mode": "id"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        -4864,
        2416
      ],
      "id": "aff8db4a-0c79-4327-a320-7d17f2df743e",
      "name": "DOWNLOAD THE CURRENT DOC ",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "BaCkgQEh4aOXF4Og",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "9db2102a-fff5-4ba7-8591-12294c437dff",
              "name": "DOC_ID",
              "value": "={{ $json.id ||$json.body.data[0].metadata.url}}",
              "type": "string"
            },
            {
              "id": "6bf41231-c35d-4489-8c32-535865573edc",
              "name": "DOC_TYPE",
              "value": "={{ $('WEB SCRAPING WEBHOOK').isExecuted ? 'url' : $json.mimeType}}\n",
              "type": "string"
            },
            {
              "id": "7bf41231-c35d-4489-8c32-535865573edc",
              "name": "DOC_NAME",
              "value": "={{ $json.name || $json.body.data[0].metadata.url}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -5648,
        2240
      ],
      "id": "8be74ed3-f237-4bd7-8f8f-9997a572e20e",
      "name": "EXTRACT ONLY USEFUL  DOC METADATA ",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {
          "keepSource": "json"
        }
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4160,
        1536
      ],
      "id": "42ddb53f-2b3b-425e-b939-a2c2a003d518",
      "name": "EXTRACT CONTENT FROM PDF "
    },
    {
      "parameters": {
        "operation": "get",
        "documentURL": "={{ $json.DOC_ID }}"
      },
      "type": "n8n-nodes-base.googleDocs",
      "typeVersion": 2,
      "position": [
        -4160,
        1760
      ],
      "id": "88bc7f42-e422-43b5-9183-ea32b270d7ec",
      "name": "Get a document",
      "credentials": {
        "googleDocsOAuth2Api": {
          "id": "YLYNbjNBTo01t9tS",
          "name": "Google Docs account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "336aa594-5aec-4287-9af0-1c4dc2cc68a7",
              "leftValue": "={{ $json.hasProblems }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1904,
        2112
      ],
      "id": "901363b8-7993-4e91-b40c-01e6ceaba32d",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// Complete Unicode cleaning solution for Supabase Vectorstore\nconst inputData = $input.first().json;\nlet content = inputData.data  || '';\n\nfunction cleanUnicodeCharacters(text) {\n  return text\n    // Step 1: Convert basic escape sequences to actual characters\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\t/g, '\\t')\n    .replace(/\\\\r/g, '\\r')\n    \n    // Step 2: Remove or replace problematic Unicode control characters\n    .replace(/\\u0012/g, '(')          // Replace \\u0012 with opening parenthesis\n    .replace(/\\u0013/g, ')')          // Replace \\u0013 with closing parenthesis\n    .replace(/\\u0000/g, '')           // Remove null characters\n    .replace(/\\u0001/g, '')           // Remove start of heading\n    .replace(/\\u0002/g, '')           // Remove start of text\n    .replace(/\\u0003/g, '')           // Remove end of text\n    .replace(/\\u0004/g, '')           // Remove end of transmission\n    .replace(/\\u0005/g, '')           // Remove enquiry\n    .replace(/\\u0006/g, '')           // Remove acknowledge\n    .replace(/\\u0007/g, '')           // Remove bell\n    .replace(/\\u0008/g, '')           // Remove backspace\n    .replace(/\\u000B/g, '')           // Remove vertical tab\n    .replace(/\\u000C/g, '')           // Remove form feed\n    .replace(/\\u000E/g, '')           // Remove shift out\n    .replace(/\\u000F/g, '')           // Remove shift in\n    .replace(/\\u0010/g, '')           // Remove data link escape\n    .replace(/\\u0011/g, '')           // Remove device control 1\n    .replace(/\\u0014/g, '')           // Remove device control 4\n    .replace(/\\u0015/g, '')           // Remove negative acknowledge\n    .replace(/\\u0016/g, '')           // Remove synchronous idle\n    .replace(/\\u0017/g, '')           // Remove end of transmission block\n    .replace(/\\u0018/g, '')           // Remove cancel\n    .replace(/\\u0019/g, '')           // Remove end of medium\n    .replace(/\\u001A/g, '')           // Remove substitute\n    .replace(/\\u001B/g, '')           // Remove escape\n    .replace(/\\u001C/g, '')           // Remove file separator\n    .replace(/\\u001D/g, '')           // Remove group separator\n    .replace(/\\u001E/g, '')           // Remove record separator\n    .replace(/\\u001F/g, '')           // Remove unit separator\n    \n    // Step 3: Remove any remaining Unicode escape sequences\n    .replace(/\\\\u[0-9a-fA-F]{4}/g, '') // Remove Unicode escape sequences\n    .replace(/\\\\x[0-9a-fA-F]{2}/g, '') // Remove hex escape sequences\n    \n    // Step 4: Clean up quotes and backslashes safely\n    .replace(/\\\\\"/g, '\"')\n    .replace(/\\\\'/g, \"'\")\n    .replace(/\\\\\\\\/g, '\\\\')\n    \n    // Step 5: Remove any remaining problematic backslashes\n    .replace(/\\\\(?![nrtbfv\"'\\\\])/g, '')\n    \n    // Step 6: Normalize whitespace\n    .replace(/\\s+/g, ' ')\n    .replace(/\\n\\s+/g, '\\n')\n    .trim();\n}\n\nfunction removeAllUnicodeEscapes(text) {\n  // More aggressive approach - remove ALL control characters\n  return text\n    .replace(/[\\u0000-\\u001F\\u007F-\\u009F]/g, '') // Remove all control characters\n    .replace(/\\\\u[0-9a-fA-F]{4}/g, '')           // Remove Unicode escapes\n    .replace(/\\\\x[0-9a-fA-F]{2}/g, '')           // Remove hex escapes\n    .replace(/\\\\n/g, '\\n')                       // Keep newlines\n    .replace(/\\\\t/g, '\\t')                       // Keep tabs\n    .replace(/\\\\r/g, '\\r')                       // Keep carriage returns\n    .replace(/\\\\/g, '')                          // Remove remaining backslashes\n    .replace(/\\s+/g, ' ')                        // Normalize spaces\n    .trim();\n}\n\n// Try the gentle approach first, then aggressive if needed\nlet cleanedContent;\ntry {\n  cleanedContent = cleanUnicodeCharacters(content);\n  \n  // Check if there are still problematic characters\n  if (/[\\u0000-\\u001F\\u007F-\\u009F]/.test(cleanedContent) || /\\\\u[0-9a-fA-F]{4}/.test(cleanedContent)) {\n    console.log('Using aggressive cleaning due to remaining Unicode issues');\n    cleanedContent = removeAllUnicodeEscapes(content);\n  }\n} catch (error) {\n  console.log('Error in cleaning, using aggressive method:', error);\n  cleanedContent = removeAllUnicodeEscapes(content);\n}\n\nreturn [{\n  json: {\n    ...inputData,\n    content: cleanedContent,\n    document: cleanedContent,\n    text: cleanedContent,\n    processed: true,\n    unicode_cleaned: true,\n    original_length: content.length,\n    cleaned_length: cleanedContent.length\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1680,
        1968
      ],
      "id": "2267483f-956e-405c-bf3c-6c2c46fd9508",
      "name": "CLEAN THE INPUT TEXT "
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "48fb58e7-f9a3-4827-9289-befa8d91a658",
              "leftValue": "={{ $json.data.replace(/[\\n\\r\\s]/g, '').length}}",
              "rightValue": 10,
              "operator": {
                "type": "number",
                "operation": "lte"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -3024,
        2096
      ],
      "id": "6d3275c9-b508-4a95-9f8a-b583795ad48a",
      "name": "If1"
    },
    {
      "parameters": {
        "jsCode": "// Function to safely get nested property values\nfunction getNestedValue(obj, path) {\n  return path.split('.').reduce((current, key) => {\n    return current && current[key] !== undefined ? current[key] : null;\n  }, obj);\n}\n\n// Function to find markdown content in various possible locations\nfunction findMarkdownContent(inputItem) {\n  const possiblePaths = [\n    'json.body.data.0.markdown',\n    'json.data.0.markdown', \n    'json.markdown',\n    'json.body.markdown',\n    'json.data.markdown',\n    'markdown',\n    'json.body.data.markdown',\n    'json.content',\n    'json.body.content',\n    'json.text',\n    'json.body.text'\n  ];\n\n  // Try each possible path\n  for (const path of possiblePaths) {\n    const value = getNestedValue(inputItem, path);\n    if (value && typeof value === 'string') {\n      return value;\n    }\n  }\n\n  // If array exists, check first element\n  const dataArray = getNestedValue(inputItem, 'json.body.data') || \n                   getNestedValue(inputItem, 'json.data');\n  \n  if (Array.isArray(dataArray) && dataArray.length > 0) {\n    const firstItem = dataArray[0];\n    if (firstItem && typeof firstItem.markdown === 'string') {\n      return firstItem.markdown;\n    }\n    if (firstItem && typeof firstItem.content === 'string') {\n      return firstItem.content;\n    }\n    if (firstItem && typeof firstItem.text === 'string') {\n      return firstItem.text;\n    }\n  }\n\n  return null;\n}\n\n// Main processing logic\nconst results = [];\n\n// Process all input items\nfor (const inputItem of $input.all()) {\n  try {\n    // Try to find markdown content dynamically\n    let markdown = findMarkdownContent(inputItem);\n    \n    // Fallback to default if no markdown found\n    if (!markdown) {\n      console.log('No markdown content found, using default');\n      markdown = '# Default Title\\nThis is some sample markdown content.';\n    }\n    \n    // Convert Markdown string to Base64\n    const base64 = Buffer.from(markdown, 'utf-8').toString('base64');\n    \n    // Add result item\n    results.push({\n      json: {\n        base64: base64,\n        original_markdown: markdown,\n        source: 'dynamic_detection'\n      }\n    });\n    \n  } catch (error) {\n    // Handle any errors gracefully\n    console.error('Error processing input item:', error);\n    results.push({\n      json: {\n        base64: Buffer.from('# Error\\nFailed to process markdown content.', 'utf-8').toString('base64'),\n        error: error.message,\n        source: 'error_fallback'\n      }\n    });\n  }\n}\n\n// Return all results\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -5120,
        2048
      ],
      "id": "681a6610-2dd0-48e3-a334-39e3a05c57c5",
      "name": "from base 64 to markdown"
    },
    {
      "parameters": {
        "operation": "toBinary",
        "sourceProperty": "base64",
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -4912,
        2048
      ],
      "id": "cba1a98e-2aa7-41f0-9e48-95e48cbafd38",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "content": "##  MISTRAL OCR SUBWORKFLOW\n",
        "height": 320,
        "width": 848
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -3072,
        1632
      ],
      "typeVersion": 1,
      "id": "8fea1fcd-e735-457e-8a41-f019e3f3b0b9",
      "name": "Sticky Note4"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8ce75b80-4b22-480e-b25d-4727c1e82a2d",
              "leftValue": "={{ $('WEB SCRAPING WEBHOOK').isExecuted }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -5408,
        2240
      ],
      "id": "378bd260-687c-4c20-a0c1-4eb727f33d0e",
      "name": "CHECK IF TYPE OF DATA URL "
    },
    {
      "parameters": {
        "content": "## Google Drive Trigger",
        "height": 1648,
        "width": 272
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -6512,
        1616
      ],
      "typeVersion": 1,
      "id": "15766d83-6a7a-4488-9464-0b25e5f80074",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Complete Database Setup Script with Vector Search Functions (FIXED)\n-- This script sets up a complete hybrid search system with both functions\n\n-- Create extension and table (unchanged)\nCREATE EXTENSION IF NOT EXISTS vector;\n\n\n-- clear chat history  \n  -- Delete all rows only if any exist\nDO $$\nBEGIN\n    IF EXISTS (SELECT 1 FROM n8n_chat_histories) THEN\n        DELETE FROM n8n_chat_histories;\n    END IF;\nEND $$;\n\n  \n-- Clean up: Drop everything related to old table names\nDROP FUNCTION IF EXISTS hybrid_search(TEXT, VECTOR(512), INT, FLOAT, FLOAT, INT);\nDROP FUNCTION IF EXISTS search_documents_hybrid(TEXT, VECTOR(1536), INT, JSONB, FLOAT, FLOAT, INT, TEXT);\nDROP FUNCTION IF EXISTS search_similar_documents(VECTOR(1536), INT, JSONB, TEXT);\nDROP TABLE IF EXISTS hybrid_search_vector_store_table CASCADE;\nDROP TABLE IF EXISTS documents CASCADE;\nDROP TABLE IF EXISTS document_embeddings CASCADE;\nDROP TABLE IF EXISTS metadata_schema CASCADE;\n\n-- Drop indexes if they exist (in case they weren't dropped with CASCADE)\nDROP INDEX IF EXISTS hybrid_search_vector_store_table_fts_idx;\nDROP INDEX IF EXISTS hybrid_search_vector_store_table_embedding_idx;\nDROP INDEX IF EXISTS documents_fts_idx;\nDROP INDEX IF EXISTS documents_embedding_idx;\nDROP INDEX IF EXISTS documents_metadata_idx;\n\n-- Drop extensions if they exist\nDROP EXTENSION IF EXISTS vector CASCADE;\nDROP EXTENSION IF EXISTS pg_trgm CASCADE;\n\n-- Drop the old record manager table\nDROP TABLE IF EXISTS record_manager;\nDROP TABLE IF EXISTS document_records;\nDROP TABLE IF EXISTS raw_data_table;\nDROP TABLE IF EXISTS processed_files; \nDROP TABLE IF EXISTS deleted_files ; \nDROP TABLE IF EXISTS token_tracker; \n\n-- Recreate vector extension\nCREATE EXTENSION IF NOT EXISTS vector;\n\ncreate table token_tracker (\n  id uuid primary key default gen_random_uuid(),\n  created_at timestamptz default now(),\n  file_id text not null , \n\n  -- token tracking\n  prompt_tokens bigint default 0,\n  completion_tokens bigint default 0,\n  total_tokens bigint default 0,\n\n  -- content tracking\n  provided_content text,  -- user input / prompt\n  ai_response text ,         -- AI’s output\n  enhanced_chunk text -- combined reponse \n);\n\n\nCREATE TABLE processed_files (\n    file_id      text not null,\n    file_title   TEXT NOT NULL,\n    file_summary TEXT,\n    file_type    TEXT,\n    processed_at TIMESTAMPTZ DEFAULT now()\n);\n\nCREATE TABLE deleted_files (\n    file_id      text not null,\n    file_title   TEXT NOT NULL,\n    file_type    TEXT,\n    deleted_at   TIMESTAMPTZ DEFAULT now()\n);\n\n\n-- Create document records table (renamed from record_manager)\nCREATE TABLE document_records (\n    id uuid primary key default gen_random_uuid(),\n    doc_id text not null,\n    file_name text  not null , \n    type text  not null  , \n    content_hash text not null,\n    schema text ,\n    created_at timestamp with time zone default timezone('utc', now())\n);\n\n\nCREATE TABLE raw_data_table (\n    id SERIAL PRIMARY KEY,\n    created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    doc_id  text not null,\n    raw_data JSONB NOT NULL\n);\n\n-- Create metadata schema table\nCREATE TABLE metadata_schema (\n    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n    name TEXT NOT NULL UNIQUE,\n    allowed_values TEXT NOT NULL DEFAULT '',\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n\n-- Insert efficient metadata fields for RAG\nINSERT INTO metadata_schema (name, allowed_values) \nVALUES \n    ('department', 'HR,Finance,Engineering,Marketing,Sales,IT,Legal,Operations'),\n    ('file_date', 'YYYY-MM-DD');\n\n\n-- Create indexes for common query patterns\nCREATE INDEX idx_metadata_schema_name ON metadata_schema(name);\nCREATE INDEX idx_metadata_schema_created_at ON metadata_schema(created_at);\n\n-- Create the main documents table (renamed from hybrid_search_vector_store_table)\nCREATE TABLE documents (\n    id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,\n    content TEXT,\n    fts TSVECTOR GENERATED ALWAYS AS (to_tsvector('english', content)) STORED,\n    embedding VECTOR(1536),\n    metadata JSONB NOT NULL DEFAULT '{}'::jsonb,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL\n);\n\n-- Create indexes with cleaner names\nCREATE INDEX documents_fts_idx ON documents USING gin(fts);\nCREATE INDEX documents_embedding_idx ON documents USING hnsw (embedding vector_ip_ops);\nCREATE INDEX documents_metadata_idx ON documents USING gin(metadata);\n\n-- Enhanced hybrid search function with FIXED metadata filtering for new JSON schema\nCREATE OR REPLACE FUNCTION search_documents_hybrid(\n    query_text text,\n    query_embedding vector(1536),\n    match_count int,\n    metadata_filter jsonb DEFAULT '{}'::jsonb,\n    full_text_weight float DEFAULT 1,\n    semantic_weight float DEFAULT 1,\n    rrf_k int DEFAULT 50,\n    distance_method text DEFAULT 'cosine'\n)\nRETURNS TABLE (\n    id bigint,\n    content text,\n    embedding vector(1536),\n    metadata jsonb,\n    created_at timestamp with time zone,\n    -- Keyword/Full-text search results\n    keyword_score double precision,\n    keyword_rank int,\n    -- Semantic search results\n    similarity_score double precision,\n    semantic_rank int,\n    -- Final combined score\n    rrf_score double precision\n)\nLANGUAGE plpgsql AS $$\nDECLARE\n    filter_conditions text := '';\n    condition_text text;\n    field_path text;\n    operator_symbol text;\n    cast_type text;\n    condition_value text;\n    group_condition text;\n    final_where_clause text;\n    filter_item jsonb;\n    nested_filters jsonb;\n    i int;\n    j int;\nBEGIN\n    -- Validate distance method parameter\n    IF distance_method NOT IN ('cosine', 'euclidean', 'inner_product') THEN\n        RAISE EXCEPTION 'Invalid distance method: %. Supported methods are: cosine, euclidean, inner_product', distance_method;\n    END IF;\n\n    -- Build metadata filter conditions for new schema\n    IF metadata_filter != '{}'::jsonb THEN\n        -- Handle new \"filters\" array structure\n        IF metadata_filter ? 'filters' THEN\n            FOR i IN 0..jsonb_array_length(metadata_filter->'filters') - 1 LOOP\n                filter_item := metadata_filter->'filters'->i;\n                \n                -- Handle nested AND conditions\n                IF filter_item ? 'and' THEN\n                    group_condition := '';\n                    nested_filters := filter_item->'and';\n                    \n                    FOR j IN 0..jsonb_array_length(nested_filters) - 1 LOOP\n                        -- Process each AND condition\n                        field_path := 'metadata->>''' || (nested_filters->j->>'field') || '''';\n                        \n                        -- Map operators from new schema to PostgreSQL\n                        operator_symbol := CASE nested_filters->j->>'operator'\n                            WHEN 'eq' THEN '='\n                            WHEN 'neq' THEN '!='\n                            WHEN 'gt' THEN '>'\n                            WHEN 'gte' THEN '>='\n                            WHEN 'lt' THEN '<'\n                            WHEN 'lte' THEN '<='\n                            WHEN 'like' THEN 'LIKE'\n                            WHEN 'ilike' THEN 'ILIKE'\n                            WHEN 'is' THEN 'IS'\n                            WHEN 'not' THEN 'IS NOT'\n                            WHEN 'in' THEN 'IN'\n                            WHEN 'contains' THEN '@>'\n                            WHEN 'fts' THEN '@@'\n                            WHEN 'match' THEN '~'\n                            ELSE '='\n                        END;\n                        \n                        -- Handle different value types and operators\n                        IF nested_filters->j->>'operator' = 'in' THEN\n                            -- Handle IN operator with array values\n                            condition_value := '(' || string_agg(\n                                CASE \n                                    WHEN jsonb_typeof(value) = 'string' THEN '''' || replace(value#>>'{}', '''', '''''') || ''''\n                                    ELSE value#>>'{}'\n                                END, \n                                ', '\n                            ) || ')'\n                            FROM jsonb_array_elements(nested_filters->j->'value') AS value;\n                        ELSIF nested_filters->j->>'operator' = 'contains' THEN\n                            -- Handle JSONB contains operator\n                            field_path := 'metadata';\n                            condition_value := '''' || replace(nested_filters->j->>'value', '''', '''''') || '''::jsonb';\n                        ELSIF nested_filters->j->>'operator' = 'fts' THEN\n                            -- Handle full-text search\n                            field_path := 'fts';\n                            condition_value := 'websearch_to_tsquery(''' || replace(nested_filters->j->>'value', '''', '''''') || ''')';\n                        ELSIF jsonb_typeof(nested_filters->j->'value') = 'string' THEN\n                            condition_value := '''' || replace(nested_filters->j->>'value', '''', '''''') || '''';\n                        ELSIF nested_filters->j->'value' = 'null'::jsonb THEN\n                            condition_value := 'NULL';\n                        ELSE\n                            condition_value := nested_filters->j->>'value';\n                        END IF;\n                        \n                        condition_text := field_path || ' ' || operator_symbol || ' ' || condition_value;\n                        \n                        IF group_condition = '' THEN\n                            group_condition := condition_text;\n                        ELSE\n                            group_condition := group_condition || ' AND ' || condition_text;\n                        END IF;\n                    END LOOP;\n                    \n                    -- Add AND group to main filter\n                    IF group_condition != '' THEN\n                        group_condition := '(' || group_condition || ')';\n                        IF filter_conditions = '' THEN\n                            filter_conditions := group_condition;\n                        ELSE\n                            filter_conditions := filter_conditions || ' AND ' || group_condition;\n                        END IF;\n                    END IF;\n                    \n                -- Handle nested OR conditions  \n                ELSIF filter_item ? 'or' THEN\n                    group_condition := '';\n                    nested_filters := filter_item->'or';\n                    \n                    FOR j IN 0..jsonb_array_length(nested_filters) - 1 LOOP\n                        -- Process each OR condition (similar to AND above)\n                        field_path := 'metadata->>''' || (nested_filters->j->>'field') || '''';\n                        \n                        operator_symbol := CASE nested_filters->j->>'operator'\n                            WHEN 'eq' THEN '='\n                            WHEN 'neq' THEN '!='\n                            WHEN 'gt' THEN '>'\n                            WHEN 'gte' THEN '>='\n                            WHEN 'lt' THEN '<'\n                            WHEN 'lte' THEN '<='\n                            WHEN 'like' THEN 'LIKE'\n                            WHEN 'ilike' THEN 'ILIKE'\n                            WHEN 'is' THEN 'IS'\n                            WHEN 'not' THEN 'IS NOT'\n                            WHEN 'in' THEN 'IN'\n                            WHEN 'contains' THEN '@>'\n                            WHEN 'fts' THEN '@@'\n                            WHEN 'match' THEN '~'\n                            ELSE '='\n                        END;\n                        \n                        IF nested_filters->j->>'operator' = 'in' THEN\n                            condition_value := '(' || string_agg(\n                                CASE \n                                    WHEN jsonb_typeof(value) = 'string' THEN '''' || replace(value#>>'{}', '''', '''''') || ''''\n                                    ELSE value#>>'{}'\n                                END, \n                                ', '\n                            ) || ')'\n                            FROM jsonb_array_elements(nested_filters->j->'value') AS value;\n                        ELSIF nested_filters->j->>'operator' = 'contains' THEN\n                            field_path := 'metadata';\n                            condition_value := '''' || replace(nested_filters->j->>'value', '''', '''''') || '''::jsonb';\n                        ELSIF nested_filters->j->>'operator' = 'fts' THEN\n                            field_path := 'fts';\n                            condition_value := 'websearch_to_tsquery(''' || replace(nested_filters->j->>'value', '''', '''''') || ''')';\n                        ELSIF jsonb_typeof(nested_filters->j->'value') = 'string' THEN\n                            condition_value := '''' || replace(nested_filters->j->>'value', '''', '''''') || '''';\n                        ELSIF nested_filters->j->'value' = 'null'::jsonb THEN\n                            condition_value := 'NULL';\n                        ELSE\n                            condition_value := nested_filters->j->>'value';\n                        END IF;\n                        \n                        condition_text := field_path || ' ' || operator_symbol || ' ' || condition_value;\n                        \n                        IF group_condition = '' THEN\n                            group_condition := condition_text;\n                        ELSE\n                            group_condition := group_condition || ' OR ' || condition_text;\n                        END IF;\n                    END LOOP;\n                    \n                    -- Add OR group to main filter\n                    IF group_condition != '' THEN\n                        group_condition := '(' || group_condition || ')';\n                        IF filter_conditions = '' THEN\n                            filter_conditions := group_condition;\n                        ELSE\n                            filter_conditions := filter_conditions || ' AND ' || group_condition;\n                        END IF;\n                    END IF;\n                    \n                -- Handle simple direct conditions\n                ELSIF filter_item ? 'field' AND filter_item ? 'operator' THEN\n                    field_path := 'metadata->>''' || (filter_item->>'field') || '''';\n                    \n                    operator_symbol := CASE filter_item->>'operator'\n                        WHEN 'eq' THEN '='\n                        WHEN 'neq' THEN '!='\n                        WHEN 'gt' THEN '>'\n                        WHEN 'gte' THEN '>='\n                        WHEN 'lt' THEN '<'\n                        WHEN 'lte' THEN '<='\n                        WHEN 'like' THEN 'LIKE'\n                        WHEN 'ilike' THEN 'ILIKE'\n                        WHEN 'is' THEN 'IS'\n                        WHEN 'not' THEN 'IS NOT'\n                        WHEN 'in' THEN 'IN'\n                        WHEN 'contains' THEN '@>'\n                        WHEN 'fts' THEN '@@'\n                        WHEN 'match' THEN '~'\n                        ELSE '='\n                    END;\n                    \n                    -- Handle different value types\n                    IF filter_item->>'operator' = 'in' THEN\n                        condition_value := '(' || string_agg(\n                            CASE \n                                WHEN jsonb_typeof(value) = 'string' THEN '''' || replace(value#>>'{}', '''', '''''') || ''''\n                                ELSE value#>>'{}'\n                            END, \n                            ', '\n                        ) || ')'\n                        FROM jsonb_array_elements(filter_item->'value') AS value;\n                    ELSIF filter_item->>'operator' = 'contains' THEN\n                        field_path := 'metadata';\n                        IF jsonb_typeof(filter_item->'value') = 'array' THEN\n                            condition_value := '''' || filter_item->'value'::text || '''::jsonb';\n                        ELSE\n                            condition_value := '''' || replace(filter_item->>'value', '''', '''''') || '''::jsonb';\n                        END IF;\n                    ELSIF filter_item->>'operator' = 'fts' THEN\n                        field_path := 'fts';\n                        condition_value := 'websearch_to_tsquery(''' || replace(filter_item->>'value', '''', '''''') || ''')';\n                    ELSIF jsonb_typeof(filter_item->'value') = 'string' THEN\n                        condition_value := '''' || replace(filter_item->>'value', '''', '''''') || '''';\n                    ELSIF filter_item->'value' = 'null'::jsonb THEN\n                        condition_value := 'NULL';\n                    ELSE\n                        condition_value := filter_item->>'value';\n                    END IF;\n                    \n                    condition_text := field_path || ' ' || operator_symbol || ' ' || condition_value;\n                    \n                    IF filter_conditions = '' THEN\n                        filter_conditions := condition_text;\n                    ELSE\n                        filter_conditions := filter_conditions || ' AND ' || condition_text;\n                    END IF;\n                END IF;\n            END LOOP;\n        END IF;\n        \n        -- Handle legacy format (fallback for backward compatibility)\n        IF NOT (metadata_filter ? 'filters') AND metadata_filter != '{}'::jsonb THEN\n            filter_conditions := 'metadata @> ''' || metadata_filter::text || '''::jsonb';\n        END IF;\n    END IF;\n    \n    -- Build final WHERE clause\n    IF filter_conditions = '' THEN\n        final_where_clause := 'true';\n    ELSE\n        final_where_clause := filter_conditions;\n    END IF;\n\n    RETURN QUERY EXECUTE format('\n    WITH filtered_records AS (\n        SELECT * FROM documents\n        WHERE %s\n    ),\n    full_text AS (\n        SELECT \n            fr.id,\n            row_number() OVER(ORDER BY ts_rank_cd(fr.fts, websearch_to_tsquery($1)) DESC)::int as rank_ix,\n            ts_rank_cd(fr.fts, websearch_to_tsquery($1))::double precision as keyword_score\n        FROM filtered_records fr\n        WHERE fr.fts @@ websearch_to_tsquery($1)\n        ORDER BY keyword_score DESC\n        LIMIT LEAST($3, 30) * 2\n    ),\n    semantic AS (\n        SELECT \n            fr.id,\n            row_number() OVER (\n                ORDER BY CASE $8\n                    WHEN ''cosine'' THEN fr.embedding <=> $2\n                    WHEN ''euclidean'' THEN fr.embedding <-> $2\n                    WHEN ''inner_product'' THEN -(fr.embedding <#> $2)\n                END\n            )::int as rank_ix,\n            (CASE $8\n                WHEN ''cosine'' THEN 1 - (fr.embedding <=> $2)\n                WHEN ''euclidean'' THEN 1 / (1 + (fr.embedding <-> $2))\n                WHEN ''inner_product'' THEN fr.embedding <#> $2\n            END)::double precision as similarity_score\n        FROM filtered_records fr\n        ORDER BY CASE $8\n            WHEN ''cosine'' THEN fr.embedding <=> $2\n            WHEN ''euclidean'' THEN fr.embedding <-> $2\n            WHEN ''inner_product'' THEN -(fr.embedding <#> $2)\n        END\n        LIMIT LEAST($3, 30) * 2\n    ),\n    combined_results AS (\n        SELECT \n            COALESCE(ft.id, s.id) as id,\n            ft.keyword_score,\n            ft.rank_ix as keyword_rank,\n            s.similarity_score,\n            s.rank_ix as semantic_rank,\n            (COALESCE(1.0 / ($7 + ft.rank_ix), 0.0) * $5 + \n             COALESCE(1.0 / ($7 + s.rank_ix), 0.0) * $6)::double precision as rrf_score\n        FROM full_text ft\n        FULL OUTER JOIN semantic s ON ft.id = s.id\n    )\n    SELECT \n        vst.id,\n        vst.content,\n        vst.embedding,\n        vst.metadata,\n        vst.created_at,\n        cr.keyword_score,\n        cr.keyword_rank,\n        cr.similarity_score,\n        cr.semantic_rank,\n        cr.rrf_score\n    FROM combined_results cr\n    JOIN documents vst ON cr.id = vst.id\n    ORDER BY cr.rrf_score DESC\n    LIMIT LEAST($3, 30)', final_where_clause)\n    USING query_text, query_embedding, match_count, metadata_filter, full_text_weight, semantic_weight, rrf_k, distance_method;\nEND;\n$$;\n-- Fixed similarity search function with proper type casting\nCREATE OR REPLACE FUNCTION search_similar_documents(\n    query_embedding VECTOR(1536),\n    match_count INT DEFAULT 10,\n    metadata_filter JSONB DEFAULT '{}'::jsonb,\n    distance_method TEXT DEFAULT 'cosine'\n)\nRETURNS TABLE (\n    id BIGINT,\n    content TEXT,\n    metadata JSONB,\n    created_at TIMESTAMP WITH TIME ZONE,\n    similarity double precision  -- Changed from FLOAT to double precision\n)\nLANGUAGE plpgsql AS $$\nBEGIN\n    -- Validate distance method parameter\n    IF distance_method NOT IN ('cosine', 'euclidean', 'inner_product') THEN\n        RAISE EXCEPTION 'Invalid distance method: %. Supported methods are: cosine, euclidean, inner_product', distance_method;\n    END IF;\n\n    -- Execute query based on selected distance method\n    CASE distance_method\n        WHEN 'cosine' THEN\n            RETURN QUERY\n            SELECT \n                d.id,\n                d.content,\n                d.metadata,\n                d.created_at,\n                (1 - (d.embedding <=> query_embedding))::double precision AS similarity  -- FIXED: Cast to double precision\n            FROM documents d\n            WHERE d.metadata @> metadata_filter\n            ORDER BY d.embedding <=> query_embedding\n            LIMIT match_count;\n            \n        WHEN 'euclidean' THEN\n            RETURN QUERY\n            SELECT \n                d.id,\n                d.content,\n                d.metadata,\n                d.created_at,\n                (1.0 / (1.0 + (d.embedding <-> query_embedding)))::double precision AS similarity  -- FIXED: Cast to double precision\n            FROM documents d\n            WHERE d.metadata @> metadata_filter\n            ORDER BY d.embedding <-> query_embedding\n            LIMIT match_count;\n            \n        WHEN 'inner_product' THEN\n            RETURN QUERY\n            SELECT \n                d.id,\n                d.content,\n                d.metadata,\n                d.created_at,\n                (-(d.embedding <#> query_embedding))::double precision AS similarity  -- FIXED: Cast to double precision\n            FROM documents d\n            WHERE d.metadata @> metadata_filter\n            ORDER BY d.embedding <#> query_embedding DESC\n            LIMIT match_count;\n    END CASE;\nEND;\n$$;\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -6304,
        1296
      ],
      "id": "601c8dd0-bf53-4951-819b-b4c03b4ca3b8",
      "name": "Supabase /Migration",
      "credentials": {
        "postgres": {
          "id": "YRDpTKDNQPMm4nzP",
          "name": "CLAUD POSTGRES CREDENTIALS"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -6672,
        1296
      ],
      "id": "a08869b2-481d-4837-bbfb-7ba3f985bb90",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "content": "## Supabase /Migration Node: Database Setup and Migration\n\nThis node executes a comprehensive PostgreSQL script to set up, clean, and migrate a database for a hybrid search system. It's designed for use with Supabase and includes features for managing document data, embeddings, and a token tracker.\n\n### Key Actions:\n\n* **Cleanup**: Drops old tables, functions, and indexes to ensure a clean slate. This includes `hybrid_search_vector_store_table`, `documents`, `document_embeddings`, and several others.\n* **Extension Management**: Drops and recreates the `vector` extension for handling vector embeddings.\n* **Table Creation**: Creates several new or renamed tables:\n    * `token_tracker`: Stores information about tokens used, user input, AI responses, and enhanced content.\n    * `processed_files` and `deleted_files`: Track the status and history of files processed by the system.\n    * `document_records`: Manages document metadata like `doc_id`, `file_name`, and `content_hash`.\n    * `raw_data_table`: Stores raw JSON data.\n    * `metadata_schema`: Defines and stores a schema for document metadata.\n    * `documents`: The main table for storing document `content`, `embedding` vectors, and `metadata`. It's optimized with indexes for full-text search (`fts`) and vector similarity search (`hnsw`).\n* **Function Creation/Update**: Creates or replaces two crucial PostgreSQL functions:\n    * `search_documents_hybrid`: This function performs a **hybrid search** combining full-text search and semantic vector search. It supports metadata filtering and uses the **Reciprocal Rank Fusion (RRF)** algorithm to combine and re-rank results from both search types.\n    * `search_similar_documents`: This function performs a **pure semantic similarity search** based on vector embeddings, allowing for different distance methods (cosine, euclidean, inner product) and metadata filtering.\n\nI can't directly edit the code for you, but I can provide a professional-looking Sticky Note with the information you requested. You can copy and paste this into your workflow.\n\n***\n\n### ⚠️ **IMPORTANT: Database Reset and Migration** ⚠️\n\nThis workflow node performs a **complete database migration**. When executed, it will:\n\n1.  **DELETE ALL EXISTING DATA**: It will drop and recreate all tables and functions, including `documents`, `document_records`, `token_tracker`, and others.\n2.  **PERMANENT DATA LOSS**: All previously stored records, including document content, metadata, and chat history, will be **permanently deleted**.\n3.  **SETUP**: The script will then re-create the entire database schema, including the `documents` table and the `search_documents_hybrid` and `search_similar_documents` functions.\n\n**USE WITH CAUTION:** This operation is destructive and should only be used for initial setup or a full database reset. Do not run this on a production database that contains valuable data.",
        "height": 896,
        "width": 1840,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -7968,
        1088
      ],
      "id": "16c28dea-389f-41f9-b27b-351900ccab5d",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=# File Title :/n {{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_NAME }}\n# File Content: {{ $('SET PARMETER FOR NAME CONSISTENCY').item.json.CONTENT.split(/\\s+/).length > 500 ? $('SET PARMETER FOR NAME CONSISTENCY').item.json.CONTENT.split(/\\s+/).slice(0, 500).join(' ') + '...' : $('SET PARMETER FOR NAME CONSISTENCY').item.json.CONTENT }}\n",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=Task: Based on the provided file name and file content, extract a one-sentence description of what the file is about and classify the document according to the fields below.\n\nImportant:\nOnly this JSON output format is allowed:\n\n{{$json.fields_list.toJsonString()}}   \n\n\nIf you are unsure about any of these fields, output N/A for that field.\n\nContext:\n{{ $json.formatted_metadata }}"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        1664,
        1968
      ],
      "id": "eae26c10-1f14-4dbe-9892-479bb1b7e485",
      "name": "Basic LLM Chain",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "={{$json.fields_list.toJsonString()}}   \n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1808,
        2288
      ],
      "id": "f73fe59d-a164-4419-84b6-5130969ef7ec",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "name": "Replace Me",
      "typeVersion": 1,
      "position": [
        5584,
        2400
      ],
      "id": "642afab8-8db8-4a1f-aca7-74fba7850e75"
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "columnTypes"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1.1,
      "position": [
        -3600,
        2512
      ],
      "id": "b4ab76e3-18b7-43ac-b15e-f2a263adf901",
      "name": "CONCATENATE THE RESULT ",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// Extract actual JSON data from n8n structure\nconst data = $input.all().map(item => item.json);\nif (data.length === 0) return [{ json: { types: [] } }];\n\n// Function to detect actual type from string value\nfunction detectType(value) {\n  // Handle null/undefined\n  if (value === null || value === undefined) return 'null';\n  \n  // If it's already not a string, use typeof\n  if (typeof value !== 'string') {\n    if (Array.isArray(value)) return 'array';\n    if (value instanceof Date) return 'date';\n    return typeof value;\n  }\n  \n  // Handle empty strings\n  if (value.trim() === '') return 'empty_string';\n  \n  // Check for boolean values\n  const lowerValue = value.toLowerCase().trim();\n  if (['true', 'false', 'yes', 'no', '1', '0'].includes(lowerValue)) {\n    return 'boolean_like';\n  }\n  \n  // Check for integers\n  if (/^-?\\d+$/.test(value.trim())) {\n    return 'integer';\n  }\n  \n  // Check for floats/decimals\n  if (/^-?\\d*\\.\\d+$/.test(value.trim())) {\n    return 'float';\n  }\n  \n  // Check for dates (basic patterns)\n  if (/^\\d{4}-\\d{2}-\\d{2}/.test(value.trim()) || \n      /^\\d{1,2}\\/\\d{1,2}\\/\\d{4}/.test(value.trim()) ||\n      /^\\d{1,2}-\\d{1,2}-\\d{4}/.test(value.trim())) {\n    return 'date_string';\n  }\n  \n  // Default to string\n  return 'string';\n}\n\n// Function to analyze multiple values for better type detection\nfunction analyzeColumn(columnData) {\n  const types = columnData.map(detectType);\n  const typeCounts = {};\n  \n  types.forEach(type => {\n    typeCounts[type] = (typeCounts[type] || 0) + 1;\n  });\n  \n  // Find most common type\n  const mostCommonType = Object.keys(typeCounts).reduce((a, b) => \n    typeCounts[a] > typeCounts[b] ? a : b\n  );\n  \n  return {\n    inferredType: mostCommonType,\n    typeDistribution: typeCounts,\n    totalValues: columnData.length\n  };\n}\n\n// Get column names from first item\nconst columns = Object.keys(data[0]);\n\n// Analyze each column by looking at all values, not just the first\nconst columnTypes = columns.map(col => {\n  const columnValues = data.map(row => row[col]).filter(val => val !== null && val !== undefined);\n  const analysis = analyzeColumn(columnValues);\n  \n  return {\n    column: col,\n    type: analysis.inferredType,\n    //originalType: typeof data[0][col],\n    //typeDistribution: analysis.typeDistribution,\n    sampleValue: data[0][col]\n  };\n});\n\n// Just the types as array\nconst typesArray = columnTypes.map(item => item.type);\n\nreturn [{\n  json: {\n    columnTypes: columnTypes,\n    typesArray: typesArray,\n    columnNames: columns,\n    summary: {\n      totalColumns: columns.length,\n      totalRows: data.length,\n      typeBreakdown: typesArray.reduce((acc, type) => {\n        acc[type] = (acc[type] || 0) + 1;\n        return acc;\n      }, {})\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3920,
        2512
      ],
      "id": "245ea33d-8ddd-43a0-a198-9f18dd711f98",
      "name": "EXTARCT THE COLUMNS NAMES AND DTYPES FROM THE TABULAR DATA",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "content": "## GET COLUMNS NAMES AND TYPES ",
        "height": 240,
        "width": 520
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -4000,
        2416
      ],
      "id": "2e964db5-477c-46b5-aece-bfa9b950409e",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "fieldsToSummarize": {
          "values": [
            {
              "aggregation": "concatenate",
              "field": "data"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.summarize",
      "typeVersion": 1.1,
      "position": [
        -3632,
        2800
      ],
      "id": "ee3eae3e-d980-4950-a520-de0132ee7869",
      "name": "CONCATENATE THE REPSONSE",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        -3904,
        2800
      ],
      "id": "d6fd8159-0026-4282-be20-2a5ab121787d",
      "name": "GET ALL SAMPLES IN ONE FILED ",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "content": "## CONVERET EXCEL FILE TO TEXT",
        "height": 240,
        "width": 520
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -4000,
        2720
      ],
      "id": "b9048888-0d44-445d-b479-22d14d5b1a8b",
      "name": "Sticky Note8"
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "raw_data_table",
          "mode": "list",
          "cachedResultName": "raw_data_table"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "doc_id": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_ID }}",
            "raw_data": "={{ $json.toJsonString().replaceAll(/'/g, \"''\") }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": false,
              "defaultMatch": true,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "created",
              "displayName": "created",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": true,
              "removed": true
            },
            {
              "id": "doc_id",
              "displayName": "doc_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "raw_data",
              "displayName": "raw_data",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -3760,
        3104
      ],
      "id": "41fdabd8-44cb-429d-b753-605aa48c5cce",
      "name": "SAVE SAMPLES  IN JSONB FROMAT IN TABULAR_DATA_STORE TABLE",
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "YRDpTKDNQPMm4nzP",
          "name": "CLAUD POSTGRES CREDENTIALS"
        }
      }
    },
    {
      "parameters": {
        "content": "## INSERT EACH SIMPLE IN THE EXCEL FILE IN JSONB FORMAT ",
        "height": 256,
        "width": 520
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -4000,
        3024
      ],
      "id": "8a87f6f7-1566-44df-9fc9-8000fecfaf93",
      "name": "Sticky Note10"
    },
    {
      "parameters": {
        "operation": "xlsx",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4208,
        2592
      ],
      "id": "f09fb28d-ee6c-49ae-90bd-d9b14ad1915e",
      "name": "EXTRACT FROM EXCEL FILE"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4208,
        2800
      ],
      "id": "e11f7dbf-ac44-4398-96b2-567b837af0de",
      "name": "EXTRACT FROM CSV"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "a08be739-1d6f-41b6-ac2d-bdc988dbad17",
              "leftValue": "={{ $('EXTRACT FROM CSV').isExecuted }}",
              "rightValue": "=application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "b6bf54ae-487d-475a-9a38-ea8655844d57",
              "leftValue": "={{ $('EXTRACT FROM EXCEL FILE').isExecuted }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        496,
        1776
      ],
      "id": "b8ca1eab-f587-447a-ad67-33d227648852",
      "name": "IsTabular"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -6416,
        1760
      ],
      "id": "41b2474f-5150-47aa-bd61-63f57aa2a9c9",
      "name": "Schedule Trigger"
    },
    {
      "parameters": {
        "tableId": "processed_files",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "file_id",
              "fieldValue": "={{ $json.metadata?.doc_id || $json.id ||$('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_ID}}"
            },
            {
              "fieldId": "file_title",
              "fieldValue": "={{ $json.metadata?.doc_id || $json.name||$('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_NAME }}\n"
            },
            {
              "fieldId": "file_type",
              "fieldValue": "={{ $json.mimeType || \"url\" }}\n"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        5104,
        1456
      ],
      "id": "1360db0f-331f-49e4-9421-69e406c6d986",
      "name": "Create a row",
      "credentials": {
        "supabaseApi": {
          "id": "3cRXAQK1eN8QzIzJ",
          "name": "LOCAL SUPABASE V"
        }
      }
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "d3f1f448-2891-4405-8cf5-5fb846b62adf",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -6416,
        1920
      ],
      "id": "1b88b955-aec5-4af5-8536-ea04421b2686",
      "name": "WEB SCRAPING WEBHOOK",
      "webhookId": "d3f1f448-2891-4405-8cf5-5fb846b62adf"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "d4de3f44-7f0c-4e16-84b0-e18841a679d7",
              "leftValue": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').first().json.DOC_TYPE.trim() }}",
              "rightValue": "=url",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3600,
        1456
      ],
      "id": "fd8c4112-e39c-4421-b8ac-85517e24f4e0",
      "name": "isURl"
    },
    {
      "parameters": {
        "jsCode": "const inputData = $input.first().json;\nlet content = inputData.data  || '';\n\nfunction detectProblems(text) {\n  const issues = [];\n  const seen = new Set();\n  \n  for (let i = 0; i < text.length; i++) {\n    const char = text[i];\n    const code = char.charCodeAt(0);\n    \n    // Check for problematic characters\n    if ((code >= 0 && code <= 31 && code !== 9 && code !== 10 && code !== 13) || \n        (code >= 127 && code <= 159)) {\n      \n      if (!seen.has(char)) {\n        seen.add(char);\n        issues.push({\n          character: char,\n          unicode: `\\\\u${code.toString(16).padStart(4, '0').toUpperCase()}`,\n          charCode: code\n        });\n      }\n    }\n  }\n  \n  return {\n    hasProblems: issues.length > 0,\n    issues: issues\n  };\n}\n\nconst result = detectProblems(content);\n\nreturn [{\n  json: {\n    ...inputData,\n    hasProblems: result.hasProblems,\n    issues: result.issues\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2208,
        2112
      ],
      "id": "eb6c03f8-806c-42b5-a178-4e9189011be8",
      "name": "CHECK IF THERE IS CHARACTER ISSSUES IN THE PROVIDED FILE"
    },
    {
      "parameters": {
        "html": "={{ $json.data }}",
        "options": {}
      },
      "type": "n8n-nodes-base.markdown",
      "typeVersion": 1,
      "position": [
        -3840,
        2080
      ],
      "id": "191421df-0bb0-44e5-a344-9bc89080d794",
      "name": "CONVERT TO MARKDOWN"
    },
    {
      "parameters": {
        "jsCode": "// Get the input data\nconst inputData = $input.all();\n\n// Process each item in the input\nconst processedItems = inputData.map(item => {\n  // Access the data array from the input item\n  const metadataArray = item.json.data || [];\n  \n  // Format each metadata field with natural language\n  const formattedFields = metadataArray.map(field => {\n    return `The metadata field **${field.name}** has the allowed values: ${field.allowed_values}`;\n  });\n  \n  // Combine all fields into a single paragraph\n  const formattedMetadata = formattedFields.join('. ') + '.';\n  \n  // Create the fields list object\n  const fieldsList = {};\n  metadataArray.forEach(field => {\n    fieldsList[field.name] = \"<ADD>\";\n  });\n  \n  // Return the formatted result\n  return {\n    json: {\n      formatted_metadata: formattedMetadata,\n      fields_list: fieldsList\n    }\n  };\n});\n\nreturn processedItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1200,
        1968
      ],
      "id": "4c5f95c0-28b6-44ca-af99-8066c2fd76c4",
      "name": "Code7"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "Wa5dHFtg2WzmBsGw",
          "mode": "list",
          "cachedResultName": "Claud_Version_Contextual Retrievel Workflow"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "CONTENT": "={{ $json.CONTENT }}",
            "FILE_ID": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_ID }}",
            "DEPARTEMENT": "={{ $('Basic LLM Chain').item.json.output.department }}",
            "FILE_DATE": "={{ $('Basic LLM Chain').item.json.output.file_date }}"
          },
          "matchingColumns": [
            "CONTENT"
          ],
          "schema": [
            {
              "id": "CONTENT",
              "displayName": "CONTENT",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "FILE_ID",
              "displayName": "FILE_ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "DEPARTEMENT",
              "displayName": "DEPARTEMENT",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "FILE_DATE",
              "displayName": "FILE_DATE",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        2624,
        1200
      ],
      "id": "c3386876-20d0-45af-b59c-67a5f48947a9",
      "name": "Contextual Retrievel",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4160,
        1328
      ],
      "id": "b7496c97-0bed-4f37-b961-de4850fc0539",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "operation": "text",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1,
      "position": [
        -4096,
        2080
      ],
      "id": "7bb74a4b-84e8-432c-aa9d-4258d6f64810",
      "name": "EXTRACT FROM HTML "
    },
    {
      "parameters": {
        "content": "##  CONTEXTUAL RETRIEVEL\n",
        "height": 304,
        "width": 1280
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        2224,
        1104
      ],
      "typeVersion": 1,
      "id": "60cdeee7-8154-46b2-b48a-ad9ef2c3ba7e",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "operation": "move",
        "fileId": {
          "__rl": true,
          "value": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').first().json.DOC_ID}}",
          "mode": "id"
        },
        "driveId": {
          "__rl": true,
          "mode": "list",
          "value": "My Drive"
        },
        "folderId": {
          "__rl": true,
          "value": "1rRFKzWWtQ5xfruuZ3dskIeU9Q6XgOJ--",
          "mode": "list",
          "cachedResultName": "PROCESSED FILES",
          "cachedResultUrl": "https://drive.google.com/drive/folders/1rRFKzWWtQ5xfruuZ3dskIeU9Q6XgOJ--"
        }
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        4272,
        1872
      ],
      "id": "8b27ad72-0c62-4742-8566-37614c8b9253",
      "name": "Move file",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "BaCkgQEh4aOXF4Og",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cloud.llamaindex.ai/api/v1/parsing/upload",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer llx-0ZxsMBCkWWiW0pRxX4eq9rcRZ02xkv0SiVjASk2VX0AnDcQa"
            }
          ]
        },
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "parameterType": "formBinaryData",
              "name": "=file",
              "inputDataFieldName": "=data"
            },
            {
              "name": "parse_mode",
              "value": "parse_page_with_agent"
            },
            {
              "name": "model",
              "value": "openai-gpt-4-1-mini"
            },
            {
              "name": "high_res_ocr",
              "value": "true"
            },
            {
              "name": "adaptive_long_table",
              "value": "true"
            },
            {
              "name": "outlined_table_extraction",
              "value": "true"
            },
            {
              "name": "output_tables_as_HTML",
              "value": "true"
            },
            {
              "name": "webhook_url",
              "value": "https://n8nserver.ncr4ailab.de/webhook-test/0d7b1b9d-2a1f-48ed-95af-b5ef5132f7fa"
            },
            {
              "name": "parsing_instruction",
              "value": "Include image annotations with titles and descriptions in the text flow"
            },
            {
              "name": "language",
              "value": "=en"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -3872,
        4048
      ],
      "id": "0969dfea-8096-4f98-839b-2324e84ef393",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "amount": 10
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -3712,
        4048
      ],
      "id": "ce6dd918-5fcb-44e8-b12a-5fd325bbcbb9",
      "name": "Wait",
      "webhookId": "36a0e9c9-1b65-4a0f-9176-ff09273d72fd"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "id": "4e79e2e6-9fd0-4aa3-93a1-594fe36be187",
                    "leftValue": "={{ $json.status}}",
                    "rightValue": "SUCCESS",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SUCCESS"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 2
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.status}}",
                    "rightValue": "PENDING",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "11937451-7328-40ae-b9aa-34af34ca0805"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PENDING"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [
        -3536,
        4048
      ],
      "id": "7efc7679-7535-4877-a4a9-336c0b40b9b5",
      "name": "Switch"
    },
    {
      "parameters": {
        "amount": 10
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -2960,
        4064
      ],
      "id": "6f57390d-622c-4ced-aff6-cdcffcd66b27",
      "name": "Wait1",
      "webhookId": "4d0650e7-9229-4e1d-8b8a-c1fbeaab7b6d"
    },
    {
      "parameters": {
        "url": "=https://api.cloud.llamaindex.ai/api/v1/parsing/job/{{ $json.id }}/details",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2480,
        4064
      ],
      "id": "012b831e-3459-4628-bf16-ff9c566b46de",
      "name": "HTTP Request1",
      "retryOnFail": true,
      "waitBetweenTries": 60
    },
    {
      "parameters": {
        "url": "=https://api.cloud.llamaindex.ai/api/v1/parsing/job/{{ $json.id }}/result/raw/markdown",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -2912,
        3808
      ],
      "id": "34e75bb6-c889-4ed8-8a90-91442a33059a",
      "name": "HTTP Request3"
    },
    {
      "parameters": {
        "model": "openai/gpt-oss-120b",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        1664,
        2288
      ],
      "id": "3dc7fd1d-e62a-486d-ab21-13f82847dfc2",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "3YBplxts6vfr4Rs0",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "triggerOn": "specificFolder",
        "folderToWatch": {
          "__rl": true,
          "value": "1Cz1D0PMfhn5_UOiKA8p2yF-26R1w4oqR",
          "mode": "list",
          "cachedResultName": "Rag_Folder",
          "cachedResultUrl": "https://drive.google.com/drive/folders/1Cz1D0PMfhn5_UOiKA8p2yF-26R1w4oqR"
        },
        "event": "fileUpdated",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 1,
      "position": [
        -6432,
        3088
      ],
      "id": "e7f3bd00-f4ec-4bad-b049-1d25c161f106",
      "name": "WATCH FOR FILE UPDATE (TRIGGER)",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "BaCkgQEh4aOXF4Og",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "triggerOn": "specificFolder",
        "folderToWatch": {
          "__rl": true,
          "value": "1Cz1D0PMfhn5_UOiKA8p2yF-26R1w4oqR",
          "mode": "list",
          "cachedResultName": "Rag_Folder",
          "cachedResultUrl": "https://drive.google.com/drive/folders/1Cz1D0PMfhn5_UOiKA8p2yF-26R1w4oqR"
        },
        "event": "fileCreated",
        "options": {}
      },
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 1,
      "position": [
        -6448,
        2448
      ],
      "id": "7c217cd6-5ba0-4e90-b326-57a93f29584d",
      "name": "WATCH FOR FILE CREATION(TRIGGER)",
      "credentials": {
        "googleDriveOAuth2Api": {
          "id": "BaCkgQEh4aOXF4Og",
          "name": "Google Drive account"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.firecrawl.dev/v1/crawl",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"url\": \"https://www.sportnavi.de/\",\n  \"limit\": 2,\n  \"webhook\": {\n        \"url\": \"https://n8nserver.ncr4ailab.de/webhook/d3f1f448-2891-4405-8cf5-5fb846b62adf\",\n        \"events\": [ \"page\"]\n  }, \n  \"scrapeOptions\": {\n        \"formats\": [\"markdown\"]\n  }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -5760,
        1760
      ],
      "id": "13b80c32-2d13-4d75-8675-086c5e0f6bd9",
      "name": " SCRAPE WEB PAGE SETTINGS NODE ",
      "credentials": {
        "httpBearerAuth": {
          "id": "9t4XntvFXi4Cvm0w",
          "name": "Bearer Auth account"
        }
      }
    },
    {
      "parameters": {
        "content": "## CONVERT TO BINARY FILE ",
        "height": 288,
        "width": 512
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -5200,
        1936
      ],
      "id": "5c884a04-2823-4a8c-9586-2284f437b180",
      "name": "Sticky Note3"
    },
    {
      "parameters": {
        "content": "## TABULAR DATA\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTHIS  workflow is for handling tabular data from a file, likely a spreadsheet. Here is a sticky note that describes what this workflow does.\n\n📝 Tabular Data Ingestion & Schema Detection\nThis workflow is designed to automatically process tabular data from Excel or CSV files and store it in a database.\n\nFile Extraction: The workflow begins by reading data from either an Excel or a CSV file.\n\nSchema Detection: It then uses a custom code node to automatically determine the column names and data types (like string, integer, date_string) from the data.\n\nData Storage: The extracted data is aggregated and then saved into the raw_data_table in your database. Each row from the original file is stored as a JSONB object, which is efficient for storing semi-structured data.\n\nThis process allows you to ingest tabular data without having to manually define the schema beforehand.\n\n",
        "height": 1264,
        "width": 1024,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -4304,
        2336
      ],
      "id": "81f508ec-557e-42ed-ab62-6fda1457d380",
      "name": "Sticky Note6"
    },
    {
      "parameters": {
        "content": "## LlamaIndex Document Parsing Workflow\nThis workflow handles the advanced parsing of documents using the LlamaIndex API, which is especially useful for complex file types.\n\nRequest for Parsing: It starts by sending a file to the LlamaIndex API for parsing. This request includes several parameters to ensure high-quality output, such as:\n\nparse_page_with_agent: Uses an AI agent to intelligently understand the document's structure.\n\nhigh_res_ocr: Ensures accurate text extraction from images.\n\nadaptive_long_table & outlined_table_extraction: Specifically designed to handle and correctly format tables, including long or complex ones.\n\noutput_tables_as_HTML: Returns tables in a structured HTML format for easy processing.\n\nwebhook_url: A webhook is set up to receive the results once the parsing is complete, which prevents the workflow from waiting for a long period.\n\nWait for Results: The workflow enters a Wait node, which pauses the execution. This is crucial because document parsing can take time.\n\nCheck Status & Retrieve:\n\nAfter the wait, it checks the status of the parsing job.\n\nIf the status is SUCCESS, it retrieves the parsed content (likely in Markdown format).\n\nIf the status is PENDING, it enters another Wait loop and re-checks the status, creating a robust polling mechanism until the job is done.\n\nNote: The wait times in this workflow are essential and should be adjusted depending on the size and complexity of the files being processed.",
        "height": 848,
        "width": 2576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -4816,
        3664
      ],
      "id": "7863aa07-b0e3-4219-98e4-fe6b34c94032",
      "name": "Sticky Note7"
    },
    {
      "parameters": {
        "jsCode": "// N8N Universal Text to Markdown Converter\n// Works dynamically with any text input\n// Input: $input.first().json.text\n\nfunction convertTextToMarkdown(text) {\n  if (!text || typeof text !== 'string') {\n    return '';\n  }\n\n  // Normalize text - handle both literal \\n and actual newlines\n  text = text.replace(/\\\\n/g, '\\n').replace(/\\r/g, '');\n  \n  // Split into lines and clean\n  let lines = text.split('\\n')\n    .map(line => line.trim())\n    .filter(line => line.length > 0);\n  \n  if (lines.length === 0) return '';\n  \n  // Analyze the text structure dynamically\n  const analysis = analyzeTextStructure(lines);\n  \n  // Convert based on analysis\n  return processLines(lines, analysis);\n}\n\nfunction analyzeTextStructure(lines) {\n  const structure = {\n    hasNumberedSections: false,\n    hasLists: false,\n    hasTitles: false,\n    hasSubsections: false,\n    language: 'unknown',\n    contentType: 'unknown'\n  };\n  \n  // Analyze patterns\n  lines.forEach(line => {\n    // Check for numbered sections (1.1, 2.3, etc.)\n    if (line.match(/^\\d+\\.\\d*\\.?\\s+/)) {\n      structure.hasNumberedSections = true;\n    }\n    \n    // Check for lists\n    if (line.match(/^[-*+]\\s+/) || line.match(/^\\d+\\.\\s+[a-zA-Z]/)) {\n      structure.hasLists = true;\n    }\n    \n    // Check for titles (all caps or title case)\n    if (line.length > 5 && (line === line.toUpperCase() || isTitleCase(line))) {\n      structure.hasTitles = true;\n    }\n    \n    // Detect language\n    if (line.match(/[àâäéèêëïîôöùûüÿç]/)) {\n      structure.language = 'french';\n    } else if (line.match(/[áéíóúñü]/)) {\n      structure.language = 'spanish';\n    } else if (line.match(/[äöüß]/)) {\n      structure.language = 'german';\n    } else if (structure.language === 'unknown' && line.match(/[a-zA-Z]/)) {\n      structure.language = 'english';\n    }\n    \n    // Detect content type\n    if (line.includes('©') || line.includes('Copyright') || line.match(/\\d{4}/)) {\n      structure.contentType = 'document';\n    }\n  });\n  \n  return structure;\n}\n\nfunction isTitleCase(line) {\n  const words = line.split(/\\s+/);\n  return words.length > 1 && words.every(word => \n    word.length === 0 || word[0] === word[0].toUpperCase()\n  );\n}\n\nfunction processLines(lines, analysis) {\n  const result = [];\n  let i = 0;\n  let currentContext = 'none'; // 'title', 'list', 'paragraph'\n  \n  while (i < lines.length) {\n    const line = lines[i];\n    const nextLine = lines[i + 1] || '';\n    \n    // Skip obviously unwanted content\n    if (shouldSkipLine(line)) {\n      i++;\n      continue;\n    }\n    \n    // Determine line type dynamically\n    const lineType = classifyLine(line, nextLine, analysis, currentContext);\n    \n    // Process based on type\n    switch (lineType) {\n      case 'main_title':\n        if (currentContext === 'list') result.push('');\n        result.push(`# ${cleanLine(line)}`);\n        result.push('');\n        currentContext = 'title';\n        break;\n        \n      case 'section_title':\n        if (currentContext === 'list') result.push('');\n        result.push(`## ${cleanLine(line)}`);\n        result.push('');\n        currentContext = 'title';\n        break;\n        \n      case 'subsection_title':\n        if (currentContext === 'list') result.push('');\n        result.push(`### ${cleanLine(line)}`);\n        result.push('');\n        currentContext = 'title';\n        break;\n        \n      case 'list_item':\n        if (currentContext !== 'list' && currentContext !== 'none') {\n          result.push('');\n        }\n        const listItem = formatListItem(line, analysis);\n        if (listItem) result.push(listItem);\n        currentContext = 'list';\n        break;\n        \n      case 'paragraph':\n        if (currentContext === 'list') result.push('');\n        \n        // Collect continuation lines for paragraph\n        const paragraph = collectParagraph(lines, i, analysis);\n        result.push(paragraph.text);\n        result.push('');\n        i = paragraph.endIndex;\n        currentContext = 'paragraph';\n        break;\n        \n      default:\n        // Handle unknown content conservatively\n        if (line.length > 5) {\n          if (currentContext === 'list') result.push('');\n          result.push(formatText(line));\n          result.push('');\n          currentContext = 'paragraph';\n        }\n    }\n    \n    i++;\n  }\n  \n  // Clean up final output\n  return result\n    .filter(line => line !== null && line !== undefined)\n    .join('\\n')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n}\n\nfunction shouldSkipLine(line) {\n  if (!line || line.length < 2) return true;\n  \n  // Universal skip patterns\n  const skipPatterns = [\n    /^(menu|rechercher|search|navigate|page|zurück|siguiente|précédente)/i,\n    /https?:\\/\\//,\n    /www\\./,\n    /^\\d{1,2}[\\/\\-\\.]\\d{1,2}[\\/\\-\\.]\\d{2,4}/,\n    /%[0-9A-F]{2}/,\n    /^[\\s\\-\\*_=]+$/,\n    /^\\s*[<>←→↑↓]+\\s*$/\n  ];\n  \n  return skipPatterns.some(pattern => pattern.test(line)) ||\n         (line.length > 150 && !line.match(/[.!?]$/));\n}\n\nfunction classifyLine(line, nextLine, analysis, currentContext) {\n  // Dynamic classification based on content and context\n  \n  // Main titles - usually all caps or very prominent\n  if (line.length > 8 && \n      (line === line.toUpperCase() || \n       line.includes('GUIDE') || \n       line.includes('MANUAL') ||\n       line.match(/^[A-ZÀ-Ÿ][A-ZÀ-Ÿ\\s]{8,}$/))) {\n    return 'main_title';\n  }\n  \n  // Section titles - numbered or prominent\n  if (line.match(/^\\d+\\.\\s*[A-Za-zÀ-ÿ]/) ||\n      line.match(/^\\d+\\.\\d+\\.?\\s*[A-Za-zÀ-ÿ]/)) {\n    return 'section_title';\n  }\n  \n  // Subsection titles - shorter, title-case\n  if (line.length < 50 && \n      line.length > 5 &&\n      isTitleCase(line) &&\n      !line.includes('(') &&\n      !line.match(/^\\d/) &&\n      currentContext !== 'list') {\n    return 'subsection_title';\n  }\n  \n  // List items - various patterns\n  if (line.match(/^[-*+•]\\s+/) ||\n      line.match(/^\\d+\\.\\s+[a-zA-ZÀ-ÿ]/) ||\n      (line.length < 60 && \n       currentContext === 'list' && \n       !line.includes('.') &&\n       line.match(/^[A-Za-zÀ-ÿ]/))) {\n    return 'list_item';\n  }\n  \n  // Paragraphs - longer text content\n  if (line.length > 15 && \n      (line.includes(' ') || line.length > 30) &&\n      !line.match(/^\\d+\\./) &&\n      line.match(/[a-zA-ZÀ-ÿ]/)) {\n    return 'paragraph';\n  }\n  \n  return 'unknown';\n}\n\nfunction formatListItem(line, analysis) {\n  let cleaned = line\n    .replace(/^[-*+•]\\s*/, '')\n    .replace(/^\\d+\\.\\s*/, '')\n    .trim();\n  \n  if (cleaned.length === 0) return null;\n  \n  // Determine indentation based on number pattern\n  let indent = '';\n  if (line.match(/^\\d+\\.\\d+/) || line.match(/^  /)) {\n    indent = '  ';\n  }\n  \n  return `${indent}- ${cleaned}`;\n}\n\nfunction collectParagraph(lines, startIndex, analysis) {\n  const paragraphLines = [lines[startIndex]];\n  let i = startIndex + 1;\n  \n  // Collect continuation lines\n  while (i < lines.length) {\n    const line = lines[i];\n    \n    // Stop if we hit a clear structural element\n    if (shouldSkipLine(line) ||\n        line.match(/^\\d+\\.\\s*[A-Za-z]/) ||\n        line.match(/^[-*+•]\\s+/) ||\n        line === line.toUpperCase() ||\n        isTitleCase(line) && line.length < 50) {\n      break;\n    }\n    \n    // Add if it's a continuation\n    if (line.length > 10 && \n        line.match(/[a-zA-ZÀ-ÿ]/) &&\n        !line.match(/^\\d+\\./)) {\n      paragraphLines.push(line);\n      i++;\n    } else {\n      break;\n    }\n  }\n  \n  return {\n    text: formatText(paragraphLines.join(' ')),\n    endIndex: i - 1\n  };\n}\n\nfunction cleanLine(line) {\n  return line\n    .replace(/^\\d+\\.?\\s*/, '')\n    .replace(/^\\d+\\.\\d+\\.?\\s*/, '')\n    .trim();\n}\n\nfunction formatText(text) {\n  // Universal text formatting\n  text = text.replace(/\\s+/g, ' '); // Normalize spaces\n  \n  // Format parenthetical content\n  text = text.replace(/\\(([^)]{3,})\\)/g, '*($1)*');\n  \n  // Bold important terms (language-agnostic)\n  const importantPatterns = [\n    /\\b(\\d+\\s*(tabs?|onglets?|pestañas?))\\b/gi,\n    /\\b(creation|création|modification|consultation|suppression|management|gestion|administration)\\b/gi,\n    /\\b(required|obligatoires?|necessary|nécessaires?)\\b/gi,\n    /\\b(important|crucial|essential|essentiel)\\b/gi\n  ];\n  \n  importantPatterns.forEach(pattern => {\n    text = text.replace(pattern, '**$1**');\n  });\n  \n  return text.trim();\n}\n\n// === N8N CODE EXECUTION ===\n\ntry {\n  // Get input text\n  const inputText = $input.first().json.text || $input.first().json.content|| '';\n  \n  if (!inputText) {\n    return [{\n      json: {\n        error: 'No text input provided',\n        markdown: '',\n        success: false\n      }\n    }];\n  }\n  \n  // Convert to markdown\n  const markdownText = convertTextToMarkdown(inputText);\n  \n  // Create metrics\n  const inputLines = inputText.split('\\n').filter(l => l.trim().length > 0).length;\n  const outputLines = markdownText.split('\\n').filter(l => l.trim().length > 0).length;\n  const compressionRatio = Math.round((1 - markdownText.length / inputText.length) * 100);\n  \n  return [{\n    json: {\n      markdown: markdownText,\n      original_text: inputText,\n      success: true,\n      metrics: {\n        input_lines: inputLines,\n        output_lines: outputLines,\n        input_length: inputText.length,\n        output_length: markdownText.length,\n        compression_ratio: compressionRatio + '%',\n        processed_at: new Date().toISOString()\n      },\n      preview: markdownText.substring(0, 300) + (markdownText.length > 300 ? '...' : '')\n    }\n  }];\n  \n} catch (error) {\n  return [{\n    json: {\n      error: error.message,\n      markdown: '',\n      success: false,\n      original_text: $input.first().json.text || ''\n    }\n  }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -3824,
        1760
      ],
      "id": "584e7396-8239-4bbb-aab9-b891235ee5b6",
      "name": "CONVERT TO MARKDOWN "
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "213076d9-8280-4b75-99c7-5f20b0e6a430",
              "name": "data",
              "value": "={{ $json.markdown }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -3504,
        1760
      ],
      "id": "c6619ef0-ecca-43d9-b810-1e4ddaa961ac",
      "name": "ADJUST CONTENT NAME FOR CONSISTENCY"
    },
    {
      "parameters": {
        "mode": "combine",
        "fieldsToMatchString": "concatenated_columnTypes",
        "joinMode": "keepNonMatches",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -3008,
        2656
      ],
      "id": "75407864-4806-4fb5-87a3-831fcead690e",
      "name": "MERGE ALL RESPONSES ",
      "executeOnce": true
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        -2704,
        2656
      ],
      "id": "8f4d1101-2203-499f-a1ec-a37b6209634e",
      "name": "CONVERT TO ONE LIST OF ITEMS"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7727550c-344a-4e6e-aab8-960d64ea0d93",
              "name": "data",
              "value": "={{ $json.data[1].concatenated_data }}",
              "type": "string"
            },
            {
              "id": "0547fb5d-3fe5-487c-8fd3-1b8c1f302a5f",
              "name": "schema",
              "value": "={{ $json.data[0].concatenated_columnTypes }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -2352,
        2656
      ],
      "id": "7009908f-984e-492d-bf6b-7157e9b9770c",
      "name": "CHNAGE NAME FOR NAME CONSISTENCY"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "0AByb57D84R4MVq0",
          "mode": "list",
          "cachedResultName": "Claude_Version_OCR_WorkFlow"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "DOC_ID": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_ID }}"
          },
          "matchingColumns": [
            "DOC_ID"
          ],
          "schema": [
            {
              "id": "DOC_ID",
              "displayName": "DOC_ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -2672,
        1744
      ],
      "id": "0830a473-c1b7-4cae-90d5-8230d87c3bf7",
      "name": "MISTRAL OCR"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "c9fdd333-7e7c-4059-ac6d-6047150b9e89",
              "name": "CONTENT",
              "value": "={{  $json.data  }}",
              "type": "string"
            },
            {
              "id": "04d94d72-7487-459c-a88b-92f6ab9d99fd",
              "name": "schema",
              "value": "={{$json.schema}}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1392,
        2128
      ],
      "id": "b7d566d3-b547-4bdc-a31e-e36fee279759",
      "name": "SET PARMETER FOR NAME CONSISTENCY",
      "retryOnFail": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "LrQNsz91sYVsfDq5",
          "mode": "list",
          "cachedResultName": "Claud_Version_Doc_Manager"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "Content": "={{ $json.CONTENT }}",
            "Doc_ID": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_ID }}",
            "TYPE": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_TYPE }}",
            "FILE_NAME": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').item.json.DOC_NAME }}",
            "SCHEMA": "={{ $json.schema }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "Content",
              "displayName": "Content",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "Doc_ID",
              "displayName": "Doc_ID",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "SCHEMA",
              "displayName": "SCHEMA",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "TYPE",
              "displayName": "TYPE",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            },
            {
              "id": "FILE_NAME",
              "displayName": "FILE_NAME",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -512,
        2112
      ],
      "id": "3aad5cab-1ecf-4035-aa7c-e222650a86fb",
      "name": "DOC TRACKER SYSTEM SUBWORKFLOW"
    },
    {
      "parameters": {
        "content": "## 📝 Ingestion Data Validation & Update Logic\nThis workflow is a critical component of the data ingestion pipeline, responsible for preventing duplicate records and updating changed content.\n\nHASH THE CONTENT: The workflow first generates a unique hash for the incoming data. This hash serves as a unique fingerprint of the content.\n\nGET RECORD: It then checks the document_records table to see if a record with the same document ID (Doc_ID) already exists.\n\nCHECK for Duplicates:\n\nNew Item: If no record is found, it's a new document, and a new record is created.\n\n\n\n\n\n\n\nChanged Item: If a record is found but the new content hash is different from the stored hash, the old data in the documents table is deleted, and the new record is created.\n\nNo Change: If a record is found and the hashes match, the workflow stops, avoiding redundant processing.\n\nUPDATE RECORD: For new or changed items, the workflow updates the document_records table with the new content hash.\n\nThis ensures that only new or modified data is processed and indexed, improving efficiency and maintaining data integrity.",
        "height": 912,
        "width": 832
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -1104,
        1856
      ],
      "id": "99efec6c-e8cd-4a4f-baa5-66c75826158b",
      "name": "Sticky Note9"
    },
    {
      "parameters": {
        "content": "## ON CREATION ",
        "height": 496,
        "width": 272,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -6512,
        2128
      ],
      "id": "276c004a-daa5-4a25-9527-09fa7767ef78",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "content": "## Get Folder ID To Watch (For Share Point Trigger And Microsoft Drive)\n📌 Title:\nRetrieve Folder ID (for Tracking and Monitoring in Microsoft Drive)\n\n📝 Description (Sticky Note):\nI’m retrieving the folder ID in n8n from Microsoft Drive. Once I have the folder ID, I’ll set up a trigger to continuously watch the folder for changes related to RAG (Retrieve & Generate).",
        "height": 544,
        "width": 1264,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -7808,
        2176
      ],
      "id": "a7c3774b-5460-49aa-885f-249ab57226a8",
      "name": "Sticky Note12"
    },
    {
      "parameters": {
        "formTitle": "Folder ID Retrieval (for Tracking & Monitoring)",
        "formDescription": "Description:\nI’m retrieving the folder ID in n8n from Microsoft Drive. Once I have the folder ID, I’ll use a trigger to continuously watch the folder for changes related to RAG (Retrieve & Generate).",
        "formFields": {
          "values": [
            {
              "fieldLabel": "FOLDER NAME (For Tracking & Monitoring)",
              "placeholder": "provide a folder name to keep tracking",
              "requiredField": true
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.formTrigger",
      "typeVersion": 2.3,
      "position": [
        -7712,
        2384
      ],
      "id": "0326cde4-9cbd-46d7-86d5-865946b0aec9",
      "name": "On form submission1",
      "webhookId": "770f0bf3-6fdd-4799-a867-1cb957d208cb"
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "watchFolder": true,
        "folderId": {
          "__rl": true,
          "value": "=35D525225CC1BBC5!s24276bfa5e414579b252abf7b4851fa7\n",
          "mode": "id"
        },
        "options": {
          "folderChild": true
        }
      },
      "type": "n8n-nodes-base.microsoftOneDriveTrigger",
      "typeVersion": 1,
      "position": [
        -6448,
        2224
      ],
      "id": "fe0b42ee-7390-4e3c-a2d5-4ecbb7cc544c",
      "name": "ON FILE CREATION TRIGGER (MICROSOFT DRIVE) ",
      "credentials": {
        "microsoftOneDriveOAuth2Api": {
          "id": "QjDCjaOBR5xFgnVT",
          "name": "Microsoft Drive account"
        }
      }
    },
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "event": "fileUpdated",
        "watch": "selectedFolder",
        "folderId": {
          "__rl": true,
          "value": "35D525225CC1BBC5!s18af7906b5744b269e3a80ffc356f4f5",
          "mode": "id"
        },
        "options": {
          "folderChild": true
        }
      },
      "type": "n8n-nodes-base.microsoftOneDriveTrigger",
      "typeVersion": 1,
      "position": [
        -6432,
        2880
      ],
      "id": "b5d21d2e-33c6-4abf-a5ed-67f59ca2e3ac",
      "name": "WATCH FOR FILE UPDATE TRIGGER",
      "credentials": {
        "microsoftOneDriveOAuth2Api": {
          "id": "QjDCjaOBR5xFgnVT",
          "name": "Microsoft Drive account"
        }
      }
    },
    {
      "parameters": {
        "content": "## ON UPDATE",
        "height": 496,
        "width": 272,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -6512,
        2784
      ],
      "id": "36de46e0-ded9-4c48-93fd-e38d94d0b091",
      "name": "Sticky Note13"
    },
    {
      "parameters": {
        "content": "## WEB CRAWLING",
        "height": 368,
        "width": 272,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -6512,
        1712
      ],
      "id": "279c07bf-8674-4b68-80f6-f4d4e08041cf",
      "name": "Sticky Note14"
    },
    {
      "parameters": {
        "content": "## DOWNLOAD FILE ",
        "height": 272,
        "width": 528,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        -5216,
        2320
      ],
      "id": "777546cd-8485-4f80-b0be-5e722ab4e34a",
      "name": "Sticky Note15"
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": "={{ $json.DOC_ID }}"
      },
      "type": "n8n-nodes-base.microsoftOneDrive",
      "typeVersion": 1,
      "position": [
        -5040,
        2416
      ],
      "id": "9d5ceaa7-6e47-4ea9-a827-0f9bef4544b2",
      "name": "DOWNLOAD BY DOC ID",
      "credentials": {
        "microsoftOneDriveOAuth2Api": {
          "id": "QjDCjaOBR5xFgnVT",
          "name": "Microsoft Drive account"
        }
      }
    },
    {
      "parameters": {
        "resource": "folder",
        "operation": "search",
        "query": "={{ $json['FOLDER NAME (For Tracking & Monitoring)'] }}"
      },
      "type": "n8n-nodes-base.microsoftOneDrive",
      "typeVersion": 1,
      "position": [
        -7472,
        2384
      ],
      "id": "5d835433-8db1-4d72-bcab-09bfe15a7025",
      "name": "Search a folder",
      "credentials": {
        "microsoftOneDriveOAuth2Api": {
          "id": "QjDCjaOBR5xFgnVT",
          "name": "Microsoft Drive account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "5b788667-c839-4b22-b311-955b65534234",
              "leftValue": "={{ $json['FILE CHANGED'] }}",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -32,
        2112
      ],
      "id": "f4f8bb92-dbc6-468c-a15a-7a0bdebd71f5",
      "name": "If2"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "338f585b-9499-42c7-9427-d1d83941d7f2",
              "name": "Folder Name ",
              "value": "={{ $json.name }}",
              "type": "string"
            },
            {
              "id": "ea9014d3-22c8-4f24-976f-95f41ee7c0bc",
              "name": "ID",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "ccee3607-80ae-4873-a514-985897e84783",
              "name": "WEB URL ",
              "value": "={{ $json.webUrl }}",
              "type": "string"
            },
            {
              "id": "562f3851-e6f0-4179-a8f9-b2e6c8ab36a7",
              "name": "PARENT FOLDER ID",
              "value": "={{ $json.parentReference.id }}",
              "type": "string"
            },
            {
              "id": "438e4a6c-c861-4029-a873-e631b772e166",
              "name": "PRAENT FOLDER NAME",
              "value": "={{ $json.parentReference.name }}",
              "type": "string"
            },
            {
              "id": "eede2c98-3340-4913-9649-31d104492389",
              "name": "PARENT FOLDER PATH",
              "value": "={{ $json.parentReference.path }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -7184,
        2384
      ],
      "id": "f23eed22-62ba-489a-8a4c-25644d16c902",
      "name": "Parent Folder"
    },
    {
      "parameters": {
        "resource": "folder",
        "folderId": "={{ $json.ID }}"
      },
      "type": "n8n-nodes-base.microsoftOneDrive",
      "typeVersion": 1,
      "position": [
        -6896,
        2384
      ],
      "id": "2f234767-f070-4fe0-bc3a-97a59f9f5008",
      "name": "Get items in a folder",
      "credentials": {
        "microsoftOneDriveOAuth2Api": {
          "id": "QjDCjaOBR5xFgnVT",
          "name": "Microsoft Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "copy",
        "fileId": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').first().json.DOC_ID}}",
        "additionalFields": {},
        "parentReference": {
          "path": "/drive/root:/Rag/PROCESSED FILES"
        }
      },
      "type": "n8n-nodes-base.microsoftOneDrive",
      "typeVersion": 1,
      "position": [
        4096,
        1712
      ],
      "id": "104b8c5e-660b-4a2f-b267-32eea16440c1",
      "name": "Copy a file1",
      "credentials": {
        "microsoftOneDriveOAuth2Api": {
          "id": "QjDCjaOBR5xFgnVT",
          "name": "Microsoft Drive account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "fileId": "={{ $('EXTRACT ONLY USEFUL  DOC METADATA ').first().json.DOC_ID}}"
      },
      "type": "n8n-nodes-base.microsoftOneDrive",
      "typeVersion": 1,
      "position": [
        4096,
        1936
      ],
      "id": "3d2ea03e-34d8-4cbb-bdad-475377d4a54c",
      "name": "Delete a file",
      "credentials": {
        "microsoftOneDriveOAuth2Api": {
          "id": "QjDCjaOBR5xFgnVT",
          "name": "Microsoft Drive account"
        }
      }
    },
    {
      "parameters": {
        "height": 528,
        "width": 576
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        3904,
        1600
      ],
      "id": "5ad5a5ab-46cc-4679-bdb5-054ff0656411",
      "name": "Sticky Note16"
    }
  ],
  "connections": {
    "Loop Over Items": {
      "main": [
        [],
        [
          {
            "node": "EXTRACT ONLY USEFUL  DOC METADATA ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GET COTENT TO FEED TO THE VECTORE TO STORE ": {
      "main": [
        [
          {
            "node": "Contextual Retrievel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SWITCH ON FILE TYPE ": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "EXTRACT CONTENT FROM PDF ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get a document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "EXTRACT FROM HTML ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "EXTRACT FROM HTML ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "EXTRACT FROM EXCEL FILE",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "EXTRACT FROM EXCEL FILE",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "EXTRACT FROM CSV",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EXTRACT ONLY USEFUL  DOC METADATA ": {
      "main": [
        [
          {
            "node": "CHECK IF TYPE OF DATA URL ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EXTRACT CONTENT FROM PDF ": {
      "main": [
        [
          {
            "node": "CONVERT TO MARKDOWN ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a document": {
      "main": [
        [
          {
            "node": "CONVERT TO MARKDOWN ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "CLEAN THE INPUT TEXT ",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "SET PARMETER FOR NAME CONSISTENCY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CLEAN THE INPUT TEXT ": {
      "main": [
        [
          {
            "node": "SET PARMETER FOR NAME CONSISTENCY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If1": {
      "main": [
        [
          {
            "node": "MISTRAL OCR",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "CHECK IF THERE IS CHARACTER ISSSUES IN THE PROVIDED FILE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "from base 64 to markdown": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert to File": {
      "main": [
        [
          {
            "node": "SWITCH ON FILE TYPE ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CHECK IF TYPE OF DATA URL ": {
      "main": [
        [
          {
            "node": "from base 64 to markdown",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DOWNLOAD BY DOC ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Supabase /Migration",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain": {
      "main": [
        [
          {
            "node": "GET COTENT TO FEED TO THE VECTORE TO STORE ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Replace Me": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CONCATENATE THE RESULT ": {
      "main": [
        [
          {
            "node": "MERGE ALL RESPONSES ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EXTARCT THE COLUMNS NAMES AND DTYPES FROM THE TABULAR DATA": {
      "main": [
        [
          {
            "node": "CONCATENATE THE RESULT ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CONCATENATE THE REPSONSE": {
      "main": [
        [
          {
            "node": "MERGE ALL RESPONSES ",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "GET ALL SAMPLES IN ONE FILED ": {
      "main": [
        [
          {
            "node": "CONCATENATE THE REPSONSE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EXTRACT FROM EXCEL FILE": {
      "main": [
        [
          {
            "node": "EXTARCT THE COLUMNS NAMES AND DTYPES FROM THE TABULAR DATA",
            "type": "main",
            "index": 0
          },
          {
            "node": "GET ALL SAMPLES IN ONE FILED ",
            "type": "main",
            "index": 0
          },
          {
            "node": "SAVE SAMPLES  IN JSONB FROMAT IN TABULAR_DATA_STORE TABLE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EXTRACT FROM CSV": {
      "main": [
        [
          {
            "node": "GET ALL SAMPLES IN ONE FILED ",
            "type": "main",
            "index": 0
          },
          {
            "node": "SAVE SAMPLES  IN JSONB FROMAT IN TABULAR_DATA_STORE TABLE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IsTabular": {
      "main": [
        [
          {
            "node": "Replace Me",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Code7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": " SCRAPE WEB PAGE SETTINGS NODE ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create a row": {
      "main": [
        [
          {
            "node": "Replace Me",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WEB SCRAPING WEBHOOK": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "isURl": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Copy a file1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Delete a file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CHECK IF THERE IS CHARACTER ISSSUES IN THE PROVIDED FILE": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CONVERT TO MARKDOWN": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code7": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Contextual Retrievel": {
      "main": [
        [
          {
            "node": "isURl",
            "type": "main",
            "index": 0
          },
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "CONVERT TO MARKDOWN ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "EXTRACT FROM HTML ": {
      "main": [
        [
          {
            "node": "CONVERT TO MARKDOWN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "HTTP Request3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request3": {
      "main": [
        [
          {
            "node": "SET PARMETER FOR NAME CONSISTENCY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "CONVERT TO MARKDOWN ": {
      "main": [
        [
          {
            "node": "ADJUST CONTENT NAME FOR CONSISTENCY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ADJUST CONTENT NAME FOR CONSISTENCY": {
      "main": [
        [
          {
            "node": "If1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MERGE ALL RESPONSES ": {
      "main": [
        [
          {
            "node": "CONVERT TO ONE LIST OF ITEMS",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CONVERT TO ONE LIST OF ITEMS": {
      "main": [
        [
          {
            "node": "CHNAGE NAME FOR NAME CONSISTENCY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CHNAGE NAME FOR NAME CONSISTENCY": {
      "main": [
        [
          {
            "node": "SET PARMETER FOR NAME CONSISTENCY",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MISTRAL OCR": {
      "main": [
        [
          {
            "node": "CHECK IF THERE IS CHARACTER ISSSUES IN THE PROVIDED FILE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SET PARMETER FOR NAME CONSISTENCY": {
      "main": [
        [
          {
            "node": "DOC TRACKER SYSTEM SUBWORKFLOW",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DOC TRACKER SYSTEM SUBWORKFLOW": {
      "main": [
        [
          {
            "node": "IsTabular",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "On form submission1": {
      "main": [
        [
          {
            "node": "Search a folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ON FILE CREATION TRIGGER (MICROSOFT DRIVE) ": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "WATCH FOR FILE UPDATE TRIGGER": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DOWNLOAD BY DOC ID": {
      "main": [
        [
          {
            "node": "SWITCH ON FILE TYPE ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Search a folder": {
      "main": [
        [
          {
            "node": "Parent Folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parent Folder": {
      "main": [
        [
          {
            "node": "Get items in a folder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Copy a file1": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete a file": {
      "main": [
        [
          {
            "node": "Create a row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "764abf43019c66c51279befb0403092fc7e1beab1eff90fa2cd5f93d91d18c8a"
  }
}
