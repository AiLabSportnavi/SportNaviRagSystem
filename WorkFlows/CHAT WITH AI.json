{
  "nodes": [
    {
      "parameters": {
        "method": "POST",
        "url": "https://nzvbgbkgoudkimnwetiz.supabase.co/functions/v1/NAIVE-RAG",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "=tell me about rag"
            },
            {
              "name": "distance_method",
              "value": "inner_product"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1360,
        224
      ],
      "id": "fe023a69-a73c-46f3-8a41-799b559e9584",
      "name": "Naive Retrievel",
      "credentials": {
        "supabaseApi": {
          "id": "3cRXAQK1eN8QzIzJ",
          "name": "LOCAL SUPABASE V"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://nzvbgbkgoudkimnwetiz.supabase.co/functions/v1/HYBRID-SEARCH",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "=query",
              "value": "={{ $('When chat message received').first().json.chatInput }}"
            },
            {
              "name": "distance_method",
              "value": "cosine"
            },
            {
              "name": "metadata_filter",
              "value": "={{ $json.output }}"
            }
          ]
        },
        "options": {
          "redirect": {
            "redirect": {}
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -1328,
        -128
      ],
      "id": "247d3d1d-5365-41b3-8019-acb7714cfe1d",
      "name": "Hybrid Retrievel",
      "credentials": {
        "supabaseApi": {
          "id": "3cRXAQK1eN8QzIzJ",
          "name": "LOCAL SUPABASE V"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Node - Sort chunks by relevance score\n// Get all input items\nconst allInputs = $input.all();\n\n// Extract results and chunks from the two input items\nlet results, chunks;\n\n// Find the item with results and the item with chunks\nfor (const input of allInputs) {\n    if (input.json.results) {\n        results = input.json.results;\n    }\n    if (input.json.chunks) {\n        chunks = input.json.chunks;\n    }\n}\n\n// Validate that we have the required data\nif (!results || !chunks) {\n    return {\n        json: {\n            error: \"Could not find 'results' or 'chunks' in input data\",\n            inputCount: allInputs.length,\n            inputStructures: allInputs.map(input => Object.keys(input.json))\n        }\n    };\n}\n\n// Create array of objects with chunk content and relevance score\ntry {\n    const chunksWithRelevance = results.map(result => ({\n        chunk: chunks[result.index],\n        relevance: result.relevance_score,\n        originalIndex: result.index\n    }));\n\n    // Sort by relevance score in descending order (highest relevance first)\n    chunksWithRelevance.sort((a, b) => b.relevance - a.relevance);\n\n    // Extract just the chunks in sorted order\n    const sortedChunks = chunksWithRelevance.map(item => item.chunk);\n\n    // Return the sorted chunks array\n    return {\n        json: {\n            sortedChunks: sortedChunks,\n            // Optional: also return with metadata if needed\n            chunksWithMetadata: chunksWithRelevance.map(item => ({\n                chunk: item.chunk,\n                relevance: item.relevance,\n                originalIndex: item.originalIndex\n            })),\n            // Summary info\n            totalChunks: sortedChunks.length,\n            highestRelevance: Math.max(...results.map(r => r.relevance_score)),\n            lowestRelevance: Math.min(...results.map(r => r.relevance_score))\n        }\n    };\n} catch (error) {\n    return {\n        json: {\n            error: \"Error processing data: \" + error.message,\n            resultsCount: results?.length,\n            chunksCount: chunks?.length\n        }\n    };\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        -64
      ],
      "id": "e5b05209-e777-421b-a9eb-e76696e3a01e",
      "name": "Code2"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        432,
        -64
      ],
      "id": "20c7225b-3f23-4023-9f25-125bdcd415e1",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Node - Extract content array from all items\n// Mode should be set to \"Run Once for All Items\"\n\n// Get all input items\nconst allItems = $input.all();\n\n// Extract content from each item\nconst contentArray = allItems.map(item => item.json.content);\n\n// Return the result as a single item with chunks array\nreturn [{\n  json: {\n    chunks: contentArray\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        -48
      ],
      "id": "10792623-db0f-4484-902d-637645d36f2f",
      "name": "Code"
    },
    {
      "parameters": {
        "fieldToSplitOut": "content",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -304,
        -48
      ],
      "id": "060ff168-17db-4a88-ae46-019de72fe4c2",
      "name": "Split Out1"
    },
    {
      "parameters": {
        "fieldToSplitOut": "results",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -528,
        -48
      ],
      "id": "0c5f92eb-57c1-4d36-9614-66916457b993",
      "name": "Split Out"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.com/v2/rerank",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "cohereApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"rerank-v3.5\",\n  \"query\":\"tell me about enural network\",\n  \"top_n\": 5,\n  \"documents\": {{JSON.stringify( $json.chunks)}}\n} ",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        192,
        -192
      ],
      "id": "156c3d0e-68a2-4948-80c3-c9432f9c9b46",
      "name": "cohere",
      "credentials": {
        "cohereApi": {
          "id": "Wt9C9x48D0s44E5O",
          "name": "CohereApi account"
        }
      }
    },
    {
      "parameters": {
        "workflowInputs": {
          "values": [
            {
              "name": "query"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -3024,
        -144
      ],
      "id": "016dfb9e-1793-44d2-8986-0aa06bc0cb83",
      "name": "When Executed by Another Workflow"
    },
    {
      "parameters": {
        "jsCode": "// Get input items from previous node\nconst items = $input.all();\n\n// Initialize output string and list of fields\nlet filterPromptInstructions = '';\nlet fieldList = '';\n\n// Function to determine if field contains datetime formats\nfunction isDatetimeField(allowedValues) {\n  if (!allowedValues) return false;\n  const datetimePatterns = ['YYYY-MM-DD', 'HH:MM:SS', 'THH:MM:SSZ'];\n  return datetimePatterns.some(pattern => allowedValues.includes(pattern));\n}\n\n// Function to determine if field is numeric range\nfunction isNumericRangeField(allowedValues) {\n  if (!allowedValues) return false;\n  return allowedValues.includes('numeric_range') || \n         allowedValues.includes('decimal_range') || \n         /\\d+-\\d+/.test(allowedValues);\n}\n\n// Function to format allowed values for display\nfunction formatAllowedValues(fieldName, allowedValues) {\n  if (!allowedValues || allowedValues.trim() === '') {\n    return \"Free text field - no predefined values\";\n  }\n  \n  if (isDatetimeField(allowedValues)) {\n    return \"Datetime format: YYYY-MM-DD\";\n  } else if (isNumericRangeField(allowedValues)) {\n    if (allowedValues.includes('decimal_range')) {\n      return \"Decimal range: 0.0 to 1.0\";\n    }\n    const ranges = allowedValues.split(',').filter(v => v.includes('-') || v.includes('+'));\n    return ranges.length > 0 ? ranges.join('\\n') : \"Numeric range values\";\n  } else if (allowedValues.includes('comma_separated_keywords')) {\n    return \"Comma-separated keywords (e.g., machine_learning,api,database)\";\n  } else {\n    // Split by comma and format as separate lines, filtering out format examples\n    const values = allowedValues.split(',')\n      .filter(v => !v.includes('_') || !v.includes('semantic_version'))\n      .filter(v => v.trim() !== '');\n    return values.join('\\n');\n  }\n}\n\n// Loop through each input item\nfor (const item of items) {\n  const data = item.json;\n  \n  // Process only if field has allowed_values\n  if (data.allowed_values && data.allowed_values.trim() !== '') {\n    // Add to filter prompt instructions\n    filterPromptInstructions += `## ${data.name}\\n`;\n    filterPromptInstructions += `The filter key ${data.name} can have the following possible values\\n\\n`;\n    filterPromptInstructions += formatAllowedValues(data.name, data.allowed_values) + '\\n';\n    \n    // Add to field list\n    if (fieldList !== '') {\n      fieldList += ',';\n    }\n    fieldList += `\"${data.name}\":\"<ADD>\"`;\n  }\n}\n\n// Return the final output\nreturn [{\n  json: {\n    \"filterPromptInstructions\": filterPromptInstructions.trim(),\n    \"list_of_fields\": fieldList\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2384,
        -128
      ],
      "id": "fb3183d3-f691-4b91-b774-298d4c145a91",
      "name": "Code4"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $('When chat message received').first().json.chatInput }}",
        "hasOutputParser": true,
        "messages": {
          "messageValues": [
            {
              "message": "=# Enhanced Metadata Filter System Prompt\n\n## Core Task\nAnalyze user queries and generate JSON filters using ONLY the available metadata fields and values from `{{ $json.filterPromptInstructions }}`.\n\n## Available Metadata Fields\nThe system will provide available fields and their possible values in `{{ $json.filterPromptInstructions }}`.\n\n**Example metadata structure:**\n```json\n{\n  \"department\": [\"IT\", \"Engineering\", \"Marketing\", \"Sales\", \"HR\"],\n  \"blobType\": [\"text/plain\", \"application/pdf\", \"image/jpeg\", \"application/json\"],\n  \"source\": [\"blob\", \"upload\", \"api\", \"import\"],\n  \"priority\": [1, 2, 3, 4, 5],\n  \"status\": [\"draft\", \"published\", \"archived\", \"pending\"],\n  \"tags\": [\"urgent\", \"confidential\", \"public\", \"internal\"]\n}\n```\n\n## Intelligence Rules\n\n### 1. **Strict Field Validation**\n- ✅ ONLY use fields that exist in `{{ $json.filterPromptInstructions }}`\n- ✅ ONLY use values that are listed for each field\n- ❌ NEVER create new fields or guess values\n- ❌ NEVER use fields not provided in the metadata\n\n### 2. **Intent Inference Patterns**\n\n#### **Department/Team Queries**\n- \"IT documents\", \"engineering files\", \"marketing materials\" → `department` field\n- \"from HR\", \"sales team\", \"dev team\" → `department` field\n\n#### **File Type Queries**  \n- \"PDF files\", \"text documents\", \"images\" → `blobType` field\n- \"JSON data\", \"plain text\", \"documents\" → `blobType` field\n\n#### **Status/State Queries**\n- \"published content\", \"draft documents\", \"archived files\" → `status` field\n- \"pending items\", \"active documents\" → `status` field\n\n#### **Priority Queries**\n- \"high priority\", \"urgent\", \"important\" → `priority` field (high values)\n- \"low priority\", \"minor\" → `priority` field (low values)\n\n#### **Source Queries**\n- \"uploaded files\", \"imported data\", \"API content\" → `source` field\n\n#### **Tag-based Queries**\n- \"confidential documents\", \"public files\", \"internal use\" → `tags` field\n- \"urgent items\", \"sensitive data\" → `tags` field\n\n### 3. **Query Analysis Logic**\n```\n1. Extract key terms from user query\n2. Check if terms match any field names (exact or synonyms)\n3. Check if terms match any field values (exact or synonyms)\n4. Map user intent to appropriate operators\n5. Generate filter or return empty if no matches\n```\n\n### 4. **Operator Selection Rules**\n\n| User Intent | Operator | Example |\n|-------------|----------|---------|\n| Exact match | `eq` | \"IT documents\" → `{\"field\": \"department\", \"operator\": \"eq\", \"value\": \"IT\"}` |\n| Exclusion | `neq` | \"not archived\" → `{\"field\": \"status\", \"operator\": \"neq\", \"value\": \"archived\"}` |\n| Multiple options | `in` | \"PDF or images\" → `{\"field\": \"blobType\", \"operator\": \"in\", \"value\": [\"application/pdf\", \"image/jpeg\"]}` |\n| Minimum threshold | `gte` | \"high priority\" → `{\"field\": \"priority\", \"operator\": \"gte\", \"value\": 4}` |\n| Maximum threshold | `lte` | \"low priority\" → `{\"field\": \"priority\", \"operator\": \"lte\", \"value\": 2}` |\n| Contains (arrays) | `cs` | \"urgent items\" → `{\"field\": \"tags\", \"operator\": \"cs\", \"value\": [\"urgent\"]}` |\n| Text search | `ilike` | \"contains 'report'\" → `{\"field\": \"title\", \"operator\": \"ilike\", \"value\": \"%report%\"}` |\n\n## Examples\n\n### Simple Queries\n```\nQuery: \"show me IT documents\"\nAnalysis: \"IT\" matches department value\nOutput: {\n  \"filter\": {\n    \"conditions\": [\n      {\"field\": \"department\", \"operator\": \"eq\", \"value\": \"IT\"}\n    ]\n  }\n}\n\nQuery: \"PDF files only\"\nAnalysis: \"PDF\" maps to \"application/pdf\" in blobType\nOutput: {\n  \"filter\": {\n    \"conditions\": [\n      {\"field\": \"blobType\", \"operator\": \"eq\", \"value\": \"application/pdf\"}\n    ]\n  }\n}\n\nQuery: \"high priority items\"\nAnalysis: \"high priority\" maps to priority >= 4\nOutput: {\n  \"filter\": {\n    \"conditions\": [\n      {\"field\": \"priority\", \"operator\": \"gte\", \"value\": 4}\n    ]\n  }\n}\n\nQuery: \"not archived files\"\nAnalysis: \"not archived\" maps to status != \"archived\"\nOutput: {\n  \"filter\": {\n    \"conditions\": [\n      {\"field\": \"status\", \"operator\": \"neq\", \"value\": \"archived\"}\n    ]\n  }\n}\n```\n\n### Complex Queries\n```\nQuery: \"urgent engineering documents that are published\"\nAnalysis: Multiple conditions - tags contains \"urgent\", department = \"Engineering\", status = \"published\"\nOutput: {\n  \"filter\": {\n    \"conditions\": [\n      {\"field\": \"department\", \"operator\": \"eq\", \"value\": \"Engineering\"},\n      {\"field\": \"status\", \"operator\": \"eq\", \"value\": \"published\"},\n      {\"field\": \"tags\", \"operator\": \"cs\", \"value\": [\"urgent\"]}\n    ]\n  }\n}\n\nQuery: \"IT or Marketing documents with high priority\"\nAnalysis: (department = IT OR department = Marketing) AND priority >= 4\nOutput: {\n  \"filter\": {\n    \"conditions\": [\n      {\"field\": \"priority\", \"operator\": \"gte\", \"value\": 4}\n    ],\n    \"groups\": [\n      {\n        \"operator\": \"or\",\n        \"conditions\": [\n          {\"field\": \"department\", \"operator\": \"eq\", \"value\": \"IT\"},\n          {\"field\": \"department\", \"operator\": \"eq\", \"value\": \"Marketing\"}\n        ]\n      }\n    ]\n  }\n}\n```\n\n### No Match Scenarios\n```\nQuery: \"tell me about rag systems\"\nAnalysis: No terms match available metadata fields/values\nOutput: {\"filter\": {}}\n\nQuery: \"show me blockchain documents\"\nAnalysis: \"blockchain\" not found in any available values\nOutput: {\"filter\": {}}\n\nQuery: \"files from last week\"\nAnalysis: No date fields available in metadata\nOutput: {\"filter\": {}}\n```\n\n## Output Format\n\n### Structure\n```json\n{\n  \"filter\": {\n    \"conditions\": [\n      {\"field\": \"string\", \"operator\": \"string\", \"value\": \"any\"}\n    ],\n    \"groups\": [\n      {\n        \"operator\": \"and|or\",\n        \"conditions\": [\n          {\"field\": \"string\", \"operator\": \"string\", \"value\": \"any\"}\n        ]\n      }\n    ]\n  }\n}\n```\n\n### Empty Filter\n```json\n{\"filter\": {}}\n```\n\n## Validation Checklist\nBefore generating any filter:\n- [ ] All field names exist in `{{ $json.filterPromptInstructions }}`\n- [ ] All values are valid for their respective fields\n- [ ] Operators are appropriate for the data types\n- [ ] Logic structure matches user intent\n- [ ] Complex queries use proper grouping\n\n## Error Prevention\n- **Double-check field existence**: If unsure about a field, return empty filter\n- **Validate values**: Only use values explicitly listed in the metadata\n- **Logical grouping**: Use groups only when user query implies OR/AND logic\n- **Operator matching**: Use appropriate operators for the query intent\n\n## Common Synonyms & Mappings\n- \"docs/documents\" → look for document-related blobTypes\n- \"team/dept\" → department field  \n- \"files\" → general term, context-dependent\n- \"urgent/important/critical\" → high priority or urgent tag\n- \"recent/new\" → look for date fields or status\n- \"old/archived\" → archived status\n- \"public/private\" → look in tags or status fields"
            }
          ]
        },
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -2064,
        -128
      ],
      "id": "61185344-8afa-41aa-ab51-91274afdd8b2",
      "name": "Basic LLM Chain1"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Supabase Metadata Filtering Schema\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"filters\": {\n      \"type\": \"array\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"field\": {\n            \"type\": \"string\",\n            \"enum\": [\"source\", \"blobType\", \"department\", \"file_date\", \"file_id\"]\n          },\n          \"operator\": {\n            \"type\": \"string\",\n            \"enum\": [\n              \"eq\", \"neq\", \"gt\", \"gte\", \"lt\", \"lte\",\n              \"like\", \"ilike\", \"in\", \"contains\", \n              \"is\", \"not\"\n            ]\n          },\n          \"value\": {}\n        },\n        \"required\": [\"field\", \"operator\", \"value\"]\n      }\n    }\n  }\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -1952,
        208
      ],
      "id": "f4323b68-3bd3-4230-959d-604515af47d4",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "metadata_schema",
        "returnAll": true
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -2688,
        -128
      ],
      "id": "5962b3a6-c7e8-45d7-8569-1f863e64e99f",
      "name": "Get many rows",
      "credentials": {
        "supabaseApi": {
          "id": "3cRXAQK1eN8QzIzJ",
          "name": "LOCAL SUPABASE V"
        }
      }
    },
    {
      "parameters": {
        "public": "={{ true }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        -3008,
        80
      ],
      "id": "2c18d715-5259-4e09-857e-c1fb55cf198d",
      "name": "When chat message received",
      "webhookId": "e7db2a3a-6f1a-43c9-bed2-09b967b8e2fe"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        -2784,
        1184
      ],
      "id": "e021bcf3-9871-46fd-bf50-80c9fbef3708",
      "name": "Postgres Chat Memory",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Executes SQL queries on the raw_data_table containing JSONB data from Excel/CSV files",
        "operation": "executeQuery",
        "query": "{{ $fromAI(\"sql_query\") }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.6,
      "position": [
        -2352,
        1200
      ],
      "id": "35a14fa5-4a59-4119-ae76-087e68d51c3f",
      "name": "execute_query",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "# Returns all available doc_ids, table schemas, data types, and structure information from document_records table",
        "operation": "executeQuery",
        "query": "SELECT doc_id, file_name, schema \nFROM document_records \nWHERE type = 'Structured Data';",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.6,
      "position": [
        -2096,
        1120
      ],
      "id": "f9e2b738-6562-4300-b43d-d64668bba225",
      "name": "get_structured_data_schema",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "description": " Searches vector database and returns relevant document chunks ranked by relevance score for the user query",
        "workflowId": {
          "__rl": true,
          "value": "FWtjHkUxiab4wp5o",
          "mode": "list",
          "cachedResultName": "INGESTION WORKFLOW"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}"
          },
          "matchingColumns": [
            "query"
          ],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        -2560,
        1184
      ],
      "id": "b8683f95-6543-41ac-a215-793554acdb00",
      "name": "retrieval"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        -1408,
        1360
      ],
      "id": "3bc6894c-7d88-4eee-9d2f-cced4d8aee78",
      "name": "Postgres Chat Memory1",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Executes SQL queries on the raw_data_table containing JSONB data from Excel/CSV files",
        "operation": "executeQuery",
        "query": "{{ $fromAI(\"sql_query\") }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.6,
      "position": [
        -992,
        1296
      ],
      "id": "4d226f95-e364-4f2d-adf1-ac657d91cbb7",
      "name": "execute_query1",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "# Returns all available doc_ids, table schemas, data types, and structure information from document_records table",
        "operation": "executeQuery",
        "query": "SELECT doc_id, file_name, schema \nFROM document_records \nWHERE type = 'Structured Data';",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.6,
      "position": [
        -736,
        1184
      ],
      "id": "a1b4017f-2163-462d-8f60-69744bf36b3b",
      "name": "get_structured_data_schema1",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "description": " Searches vector database and returns relevant document chunks ranked by relevance score for the user query",
        "workflowId": {
          "__rl": true,
          "value": "FWtjHkUxiab4wp5o",
          "mode": "list",
          "cachedResultName": "INGESTION WORKFLOW"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}"
          },
          "matchingColumns": [
            "query"
          ],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        -1200,
        1360
      ],
      "id": "bcd5d54c-2b57-4661-aea4-b9dbded719f4",
      "name": "retrieval1"
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "=# AI Agent System Prompt\n\nYou are a retrieval-augmented AI agent that routes queries between structured data analysis and document retrieval based on user intent.\n\n## Decision Framework\n\n### Use Structured Data Path for:\n- **Aggregations**: SUM, COUNT, AVG, MAX, MIN operations\n- **Complex filtering, joins, statistical analysis**\n**Keywords**: \"total\", \"sum\", \"average\", \"count\", \"calculate\", \"analyze\", \"compare\", \"highest\", \"lowest\", \"breakdown\", \"trends\", \"percentage\"\n\n### Use RAG Path for:\n- **Everything else**: Explanations, policies, procedures, concepts, visual content requests\n\n## Workflow\n\n### Structured Data:\n1. Call `get_structured_data_schema` → Get available doc_ids\n2. Generate JSONB SQL query on `raw_data_table`\n3. Call `execute_query` → Present results\n\n### RAG:\n1. Call `retrieval` tool → Get relevant chunks\n2. **If URLs/images returned**: Display and cite properly\n3. Synthesize response from retrieved content\n\n## Citation Requirements\n- **Text sources**: `Source: [Document](link)` if available\n- **Images/URLs**: When retrieval returns URLs, always cite: `[Image/Source](url)`\n- **Display images**: If image URLs returned, show with `![Description](url)`\n\n## Key JSONB Operators\n- `raw_data->>'field'`: Extract as text\n- `(raw_data->>'field')::numeric`: Cast to number\n- Always filter by `doc_id` first\n\n## Available Tools\n- **`get_structured_data_schema`**: Returns doc_ids and table schemas\n- **`execute_query`**: Executes SQL on raw_data_table\n- **`retrieval`**: Searches documents, returns ranked chunks (may include URLs/images)\n\n## **CRITICAL: Honesty Protocol**\n- **If you don't know or can't find information → Say \"I don't know\"**\n- **Never fabricate or guess when tools return no/irrelevant results**\n- **Be transparent about limitations**\n\n### Format for Unknown:\n```\nI don't know [specific aspect]. \n[Optional: What was searched]\n```\n\n## Priority Order:\n1. **Structured Data** (numerical/analytical)\n2. **RAG** (text, images, everything else)\n3. **Honesty First** (always prioritize truthful \"I don't know\")"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        -2672,
        736
      ],
      "id": "8918ef18-6142-46ff-967a-0df809e1af9a",
      "name": "AGENT FOR ALL TYPES OF DOCS"
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "=# AI Agent System Prompt\n\nYou are a retrieval-augmented AI agent that routes queries between structured data analysis and document retrieval based on user intent.\n\n## Decision Framework\n\n### Use Structured Data Path for:\n- **Aggregations**: SUM, COUNT, AVG, MAX, MIN operations\n- **Complex filtering, joins, statistical analysis**\n**Keywords**: \"total\", \"sum\", \"average\", \"count\", \"calculate\", \"analyze\", \"compare\", \"highest\", \"lowest\", \"breakdown\", \"trends\", \"percentage\"\n\n### Use RAG Path for:\n- **Everything else**: Explanations, policies, procedures, concepts, visual content requests\n\n## Workflow\n\n### Structured Data:\n1. Call `get_structured_data_schema` → Get available doc_ids\n2. Generate JSONB SQL query on `raw_data_table`\n3. Call `execute_query` → Present results\n\n### RAG:\n1. Call `retrieval` tool → Get relevant chunks\n2. **If URLs/images returned**: Display and cite properly\n3. Synthesize response from retrieved content\n\n## Citation Requirements\n- **Text sources**: `Source: [Document](link)` if available\n- **Images/URLs**: When retrieval returns URLs, always cite: `[Image/Source](url)`\n- **Display images**: If image URLs returned, show with `![Description](url)`\n\n## Key JSONB Operators\n- `raw_data->>'field'`: Extract as text\n- `(raw_data->>'field')::numeric`: Cast to number\n- Always filter by `doc_id` first\n\n## Available Tools\n- **`get_structured_data_schema`**: Returns doc_ids and table schemas\n- **`execute_query`**: Executes SQL on raw_data_table\n- **`retrieval`**: Searches documents, returns ranked chunks (may include URLs/images)\n\n## **CRITICAL: Honesty Protocol**\n- **If you don't know or can't find information → Say \"I don't know\"**\n- **Never fabricate or guess when tools return no/irrelevant results**\n- **Be transparent about limitations**\n\n### Format for Unknown:\n```\nI don't know [specific aspect]. \n[Optional: What was searched]\n```\n\n## Priority Order:\n1. **Structured Data** (numerical/analytical)\n2. **RAG** (text, images, everything else)\n3. **Honesty First** (always prioritize truthful \"I don't know\")"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        -1312,
        768
      ],
      "id": "2a10dee5-08b6-442c-b7db-66b2a6d82c39",
      "name": "AGENT FOR HYBRID SEARCH RESPONSES"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        -96,
        1472
      ],
      "id": "64eee54c-d428-41e4-85a1-72f9ab65d561",
      "name": "Postgres Chat Memory2",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "Executes SQL queries on the raw_data_table containing JSONB data from Excel/CSV files",
        "operation": "executeQuery",
        "query": "{{ $fromAI(\"sql_query\") }}",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.6,
      "position": [
        512,
        1456
      ],
      "id": "42025e6d-8b17-4f44-903c-9ea07f82acd5",
      "name": "execute_query2",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "descriptionType": "manual",
        "toolDescription": "# Returns all available doc_ids, table schemas, data types, and structure information from document_records table",
        "operation": "executeQuery",
        "query": "SELECT doc_id, file_name, schema \nFROM document_records \nWHERE type = 'Structured Data';",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.6,
      "position": [
        848,
        1376
      ],
      "id": "238722c6-f236-4328-b733-1669305ca6ab",
      "name": "get_structured_data_schema2",
      "credentials": {
        "postgres": {
          "id": "TbDxKkVCtZI8qcev",
          "name": "LOCAL POSTGRES  Credentials"
        }
      }
    },
    {
      "parameters": {
        "description": " Searches vector database and returns relevant document chunks ranked by relevance score for the user query",
        "workflowId": {
          "__rl": true,
          "value": "FWtjHkUxiab4wp5o",
          "mode": "list",
          "cachedResultName": "INGESTION WORKFLOW"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "query": "={{ /*n8n-auto-generated-fromAI-override*/ $fromAI('query', ``, 'string') }}"
          },
          "matchingColumns": [
            "query"
          ],
          "schema": [
            {
              "id": "query",
              "displayName": "query",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string"
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        160,
        1504
      ],
      "id": "83cbec42-bffb-47a5-b1a7-cfc91453c74c",
      "name": "retrieval2"
    },
    {
      "parameters": {
        "options": {
          "systemMessage": "=# AI Agent System Prompt\n\nYou are a retrieval-augmented AI agent that routes queries between structured data analysis and document retrieval based on user intent.\n\n## Decision Framework\n\n### Use Structured Data Path for:\n- **Aggregations**: SUM, COUNT, AVG, MAX, MIN operations\n- **Complex filtering, joins, statistical analysis**\n**Keywords**: \"total\", \"sum\", \"average\", \"count\", \"calculate\", \"analyze\", \"compare\", \"highest\", \"lowest\", \"breakdown\", \"trends\", \"percentage\"\n\n### Use RAG Path for:\n- **Everything else**: Explanations, policies, procedures, concepts, visual content requests\n\n## Workflow\n\n### Structured Data:\n1. Call `get_structured_data_schema` → Get available doc_ids\n2. Generate JSONB SQL query on `raw_data_table`\n3. Call `execute_query` → Present results\n\n### RAG:\n1. Call `retrieval` tool → Get relevant chunks\n2. **If URLs/images returned**: Display and cite properly\n3. Synthesize response from retrieved content\n\n## Citation Requirements\n- **Text sources**: `Source: [Document](link)` if available\n- **Images/URLs**: When retrieval returns URLs, always cite: `[Image/Source](url)`\n- **Display images**: If image URLs returned, show with `![Description](url)`\n\n## Key JSONB Operators\n- `raw_data->>'field'`: Extract as text\n- `(raw_data->>'field')::numeric`: Cast to number\n- Always filter by `doc_id` first\n\n## Available Tools\n- **`get_structured_data_schema`**: Returns doc_ids and table schemas\n- **`execute_query`**: Executes SQL on raw_data_table\n- **`retrieval`**: Searches documents, returns ranked chunks (may include URLs/images)\n\n## **CRITICAL: Honesty Protocol**\n- **If you don't know or can't find information → Say \"I don't know\"**\n- **Never fabricate or guess when tools return no/irrelevant results**\n- **Be transparent about limitations**\n\n### Format for Unknown:\n```\nI don't know [specific aspect]. \n[Optional: What was searched]\n```\n\n## Priority Order:\n1. **Structured Data** (numerical/analytical)\n2. **RAG** (text, images, everything else)\n3. **Honesty First** (always prioritize truthful \"I don't know\")"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        16,
        816
      ],
      "id": "1241f9ba-9a4f-4644-8ac4-c1b1d0e42fb9",
      "name": "AGENT FOR NAIVE RAG RESPONSES"
    },
    {
      "parameters": {
        "model": "openai/gpt-oss-120b",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -2096,
        192
      ],
      "id": "c6f579ae-51ad-487d-9b33-2a7379ef0022",
      "name": "OpenRouter Chat Model",
      "credentials": {
        "openRouterApi": {
          "id": "3YBplxts6vfr4Rs0",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -1728,
        1296
      ],
      "id": "72819978-7491-47ce-8ea1-e2c1a10cdeed",
      "name": "OpenRouter Chat Model1",
      "credentials": {
        "openRouterApi": {
          "id": "3YBplxts6vfr4Rs0",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -464,
        1456
      ],
      "id": "f709ddc6-9b2c-415c-b876-3ee5f5187acd",
      "name": "OpenRouter Chat Model2",
      "credentials": {
        "openRouterApi": {
          "id": "3YBplxts6vfr4Rs0",
          "name": "OpenRouter account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenRouter",
      "typeVersion": 1,
      "position": [
        -3200,
        1248
      ],
      "id": "41911f1f-e8a6-4c56-8c37-47f19d9aba97",
      "name": "OpenRouter Chat Model3",
      "credentials": {
        "openRouterApi": {
          "id": "3YBplxts6vfr4Rs0",
          "name": "OpenRouter account"
        }
      }
    }
  ],
  "connections": {
    "Hybrid Retrievel": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Code2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          },
          {
            "node": "cohere",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out1": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "Split Out1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cohere": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code4": {
      "main": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Basic LLM Chain1": {
      "main": [
        [
          {
            "node": "Hybrid Retrievel",
            "type": "main",
            "index": 0
          },
          {
            "node": "Naive Retrievel",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Get many rows": {
      "main": [
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When chat message received": {
      "main": [
        [
          {
            "node": "Get many rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "AGENT FOR ALL TYPES OF DOCS",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "execute_query": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR ALL TYPES OF DOCS",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_structured_data_schema": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR ALL TYPES OF DOCS",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "retrieval": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR ALL TYPES OF DOCS",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Chat Memory1": {
      "ai_memory": [
        [
          {
            "node": "AGENT FOR HYBRID SEARCH RESPONSES",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "execute_query1": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR HYBRID SEARCH RESPONSES",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_structured_data_schema1": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR HYBRID SEARCH RESPONSES",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "retrieval1": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR HYBRID SEARCH RESPONSES",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Chat Memory2": {
      "ai_memory": [
        [
          {
            "node": "AGENT FOR NAIVE RAG RESPONSES",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "execute_query2": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR NAIVE RAG RESPONSES",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "get_structured_data_schema2": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR NAIVE RAG RESPONSES",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "retrieval2": {
      "ai_tool": [
        [
          {
            "node": "AGENT FOR NAIVE RAG RESPONSES",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AGENT FOR HYBRID SEARCH RESPONSES",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model2": {
      "ai_languageModel": [
        [
          {
            "node": "AGENT FOR NAIVE RAG RESPONSES",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "OpenRouter Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "AGENT FOR ALL TYPES OF DOCS",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {
    "Basic LLM Chain1": [
      {
        "output": {
          "filters": []
        }
      }
    ]
  },
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "764abf43019c66c51279befb0403092fc7e1beab1eff90fa2cd5f93d91d18c8a"
  }
}
